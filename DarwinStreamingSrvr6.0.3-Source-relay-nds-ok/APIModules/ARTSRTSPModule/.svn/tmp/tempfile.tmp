/*
    File:       ARTSRTSPModule.cpp

    Contains:   Implements a module to fetch backend content from ARTS

    
*/
#define ADAPTATION_FLAG      0x20 
#define MPEG2_DATA           0x40
#define PCR_FLAG             0x10
#define DISCONTINUITY_FLAG   0x80
#define MIN_PACK_LEN_FOR_PCR 12
#define MP2_PKTS_TO_READ     7
#define DO_BLOCK_READ        0

#define MAXUINT32            0xffffffff

#define ARTSMAX(a,b)  ((a)>(b)?(a):(b))
#define ARTSMIN(a,b)  ((a)<(b)?(a):(b))
#define MAXBUFFERDURATION  3000



bool pmt_readed=false;
bool pat_readed= false;

bool pmt_sent= false;
bool pat_sent= false;

int pat_num;
int pmt_num;





enum debug_level_t {
    NONE_ARTS_MODULE = 0,
    INFO_ARTS_MODULE,
    DEBUG_ARTS_MODULE
};

static debug_level_t ARTS_MODULE_DEBUG_LEVEL =INFO_ARTS_MODULE;
//#if DO_BLOCK_READ
#define MAX_RTP_PACKET_BUFFER_LEN 500
#define MIN_RTP_PACKET_BUFFER_LEN 1
#define TS_PACKET_SIZE 188
#define TS_TCP_PACKET_SIZE 188*7
//#endif

#include "QTSServerInterface.h"
#include "ARTSRTSPModule.h"
#include "QTSSMemoryDeleter.h"
#include "QTSSModuleUtils.h"
#include "QTSSRollingLog.h"
#include "OSMemory.h"
#include "Task.h"
#include "SDPUtils.h"
#include "RTSPProtocol.h"
#include "RTSPRequestInterface.h"
#include "RTSPSession.h"
#include "RTPSession.h"
#include "RTCPPacket.h"
#include "RTCPAPPPacket.h"
#include "ARTSutil.h"
#include "arts_send_pkt_thread.h"
#include "ts-demux.h"

extern "C" {
#include "fdevent.h"
#include "arts_ph_common.h"

}

#include <netinet/in.h>  
#include <netinet/sctp.h>
#include <arpa/inet.h>
#include <stdlib.h>

#include <stdint.h>
// #include "arts_protobuf_common.pb.h"
#include <cstdarg>


namespace proto64{
enum ConnectionReleaseReason {
  Normal = 0,
  NotFound = 1,
  BadRequest = 2,
  Unauthorized = 3,
  Forbidden = 4,
  Aborted = 5,
  UserDisconnected = 6,
  Rejected = 7,
  MaxLimitExceeded = 8,
  MediaSetupError = 9,
  SourceUnreachable = 10,
  PHDisconnected = 11,
  AdapterDisconnected = 12,
  ScriptError = 13,
  InternalStateMismatch = 14,
  InternalGenericError = 15,
  ResourceUnavailable = 16,
  LoadBalancerReject = 17,
  LastConnectionReleaseReasonEnum = 18,
  ScriptDisabled = 19,
  AdapterTimeOut = 20,
  ScriptTimeOut  = 21
};
}

#define  MAX_HANDLE_DIR 50
#define  TYPE_TO_C(t) (((t)==2)?'a':((t)==3)?'v':'u')

static void *  
debug_malloc(size_t size, const char *file, int line, const char *func)  
{  
        void *p;  
  
        p = malloc(size);  
        printf("%s:%d:%s:malloc(%ld): p=0x%lx\n",  
            file, line, func, size, (unsigned long)p);  
        return p;  
}  
  
#define av_malloc(s) debug_malloc(s, __FILE__, __LINE__, __func__)  

#define av_freep(p)  do {	\
        printf("%s:%d:%s:freep(0x%lx)\n", __FILE__, __LINE__,__func__, (unsigned long)*p);	\
	free(p);	\
} while (0)  


//------------------------------------------------------------------------
// CONTROLLER INTERFACE CLASS
//------------------------------------------------------------------------
typedef struct
{
    char sessionID[256];
    TCPSocket *sock;
    bool     used;
    void     *next;
    RTSPSession  *rtspSessObj;
    RTPSession   *rtpSessObj;   
}co_socket_t;




typedef struct event_node
{
    int callid;
    int events;
    int64_t stop_time;   //at the time of this obj->fd unregister
    void *next;
    bool unregister ;
    void *sess;
    int fd;
}event_node_t;



class ARTS_PH_Interface : public OSThread
{
public:
    ARTS_PH_Interface();
    ~ARTS_PH_Interface();
    bool Configure(char *pBackends,char * pBindHost ,UInt16 lport);
    virtual void Entry();

    fdevents *ev;           /* Event handlers */
    arts_controlfd_state_t control_state;/* State of Controller Connection */
    int callid;                         /* Call Id for incoming call */
    unsigned char phid;                 /* PH ID assigned by the controller */
    iosocket *controlsock;              /* iosocket for SCTP to Controller */
    int controllertimeout;              /* Number of seconds to wait before retrying controller */
    int listenport;                     /* Port for Listening to SCTP connections */
    iosocket *listensock;               /* iosocket for Listening */   
    int polltimeout; 
   // char tmpbuffer[ARTS_IPC_MAX_ENCODED_PDU_SIZE+1];
    char tmpbuffer[3948];
    OSMutex sessionMutex;
    co_socket_t* co_socket_list;
    event_node_t * stop_events;
    bool lock;
private:
    void Trigger();
    struct sockaddr_in servaddr;    /* ARTS Controller Address */
    
    
};




//------------------------------------------------------------------------
// STATIC DATA
//------------------------------------------------------------------------


 FILE *inputfile;
 
class QTSSARTSAccessLog;
static QTSS_ModulePrefsObject sPrefs = NULL;
static QTSS_PrefsObject sServerPrefs = NULL;
static QTSS_ServerObject sServer = NULL;
static Bool16  dump_input = false;
static Bool16  dump_output = false;
static Bool16  sARTSSupportOtherChannel = false;
static char* sARTSInputFile = NULL;
static UInt32  sARTSIpqamPCRInterval =40;
static UInt32  sARTSIpqamDefaultPCRInterval = 40;
static char*  sARTSIpqamHost = NULL;
static UInt16 sARTSIpqamPort = 49184;
static UInt64 sARTSIpqamBitrate = 6500000;  
static char*  sARTSBackends = NULL;
static char*  sDefaultARTSBackends = "127.0.0.1:9000";
static char*  sDefaultARTSBindHost = NULL;  // When NULL DArwin will bind to INADDR_ANY 
static char*  sARTSBindHost = NULL;
static char*  sARTSHandleDir[MAX_HANDLE_DIR] = {0,};
static UInt32 sARTSNumHandleDir = 0;

static char*  sARTSSystemName = NULL;
static char*  sDefaultARTSSystemName = "ARTS RTSP Server ";
static UInt16 sARTSListenPort = 8000;
static UInt16 sDefaultARTSListenPort = 8000;

static QTSSARTSAccessLog*    sARTSAccessLog   = NULL;

static UInt32   sDefaultRollInterval    = 7;
static Bool16   sDefaultLogTimeInGMT    = true;
static UInt32   sDefaultMaxLogBytes     = 10240000;
static Bool16   sDefaultLogEnabled  = true;
static char*    sDefaultLogName     = "arts_access";
static char*    sDefaultLogDir = NULL;
static Bool16   sDefaultEnableDiffServ  = true;
static UInt16   sDefaultDSCP = 136;
// configurable parameter to tell wehther to send RTCP bye on EOS or not
static Bool16   sDefaultSendRtcpByeOnEos  = false;
static Bool16   sARTSSupportPTS = false;

static char*    sLogName        = NULL;
static char*    sLogDir         = NULL;
static Bool16   sLogEnabled     = true;
static UInt32   sMaxLogBytes    = 10240000;
static UInt32   sRollInterval   = 7;
static Bool16   sLogTimeInGMT   = true;
static Bool16   sEnableDiffServ = true;
static UInt16   sARTSDSCP = 136;
static UInt32   sARTSIpqamAheadTime =0; //in microsecond
static UInt32   sARTSIpqamAfterTime =0;
//configurable parameter to tell wehther to send RTCP bye on EOS or not
static Bool16   sSendRtcpByeOnEos     = false;

static const StrPtrLen              kCacheControlHeader("must-revalidate");

static char* sLogHeader =   "#Software: %s\n"
                                "#Version: %s\n"    //%s == version
                                "#Date: %s\n"       //%s == date/time
                                "#Remark: All date values are in %s.\n" //%s == "GMT" or "local time"
                                "#Remark: c-duration is in seconds.\n"
                                "#Fields: c-ip c-user-agent [date time] cs-uri c-status c-bytes c-duration\n";

static QTSS_AttributeID sARTSSessionAttr = qtssIllegalAttrID;
static QTSS_AttributeID sARTSRTSPSessionAttr = qtssIllegalAttrID;
static ARTS_PH_Interface *sARTSPHInterface = NULL;

static UInt64 MUX_RATE;


//------------------------------------------------------------------------
// FUNCTION PROTOTYPES
//------------------------------------------------------------------------

QTSS_Error ARTSRTSPModuleDispatch(QTSS_Role inRole, QTSS_RoleParamPtr inParams);
static QTSS_Error   Register(QTSS_Register_Params* inParams);
static QTSS_Error   Initialize(QTSS_Initialize_Params* inParams);
static QTSS_Error   RereadPrefs();
static QTSS_Error   ProcessRTSPRequest(QTSS_StandardRTSP_Params* inParams);
static QTSS_Error   Shutdown();

static QTSS_Error   ARTS_RequestEvent(Task **ppTask);
static QTSS_Error   ARTS_SignalStream(Task *pTask,int event);

static QTSS_Error ProcessRTCPPacket(QTSS_RTCPProcess_Params * inParams);
static QTSS_Error DoGetParameter(QTSS_StandardRTSP_Params* inParamBlock);
static QTSS_Error DoDescribe(QTSS_StandardRTSP_Params* inParamBlock);
static QTSS_Error DoSetup(QTSS_StandardRTSP_Params* inParamBlock);
static QTSS_Error DoDescribeAndSetup(QTSS_StandardRTSP_Params* inParamBlock, bool isMP2TSFlag=false);
static QTSS_Error DoPlay(QTSS_StandardRTSP_Params* inParamBlock, bool sendResponseFlag = 1);
static QTSS_Error DoPause(QTSS_StandardRTSP_Params* inParamBlock);
static QTSS_Error SendPackets(QTSS_RTPSendPackets_Params* inParams);
static QTSS_Error DestroySession(QTSS_ClientSessionClosing_Params* inParams);
static QTSS_Error CloseRTSPSession(QTSS_RTSPSession_Params* inParams);
static QTSS_Error GetStreamPackets(arts_session *sess, bool readAll);
static handler_t arts_handle_controller_fdevent(void *s, void *ctx, int revents);
static handler_t arts_handle_adapter_fdevent(void *s, void *ctx, int revents);
static handler_t arts_handle_listener_fdevent(void *s, void *ctx, int revents);
static void arts_rtsp_reg_handler(void *ctx, unsigned char regid);
static void arts_rtsp_conresp_handler(void *ctx, arts_session *p_sess, int count, arts_ph_keyValue *p_keyValuePairs);
static void arts_rtsp_conrel_handler(void *ctx, arts_session *p_sess, unsigned int cause);
static void arts_rtsp_flush_handler(void *ctx, arts_session *p_sess, unsigned int flush);
static void arts_rtsp_shutdown_handler(void *ctx, unsigned int ServerState);
static arts_system_load_state  arts_rtsp_loadstatus_handler();
static void LogRequest_ (const char *fmt, ...);
static void WriteStartupMessage();
static void WriteShutdownMessage();
static QTSS_Error GetARTSHandleDir();
static void UpdateRTSPStats(QTSS_ClientSessionObject &inClientSession,arts_session *sess);

static QTSS_Error DoDefault(QTSS_StandardRTSP_Params* inParams);

static SInt64 GetMPEG2PCR(UInt8 *packetData, UInt32 *remainPacketLength);
int64_t GetseekStartDts(arts_session *sess);
QTSS_Error send_play_request(UInt32 callid);
static  int64_t GetFrameDuration(arts_session *sess);
//--- this function changes the timestamp of audio and video packet in such a way that they are aligned in
//absolute running time
static void SetStreamsOffset(arts_session *sess);
static void sendAnnouce(arts_session * sess);

//**************************************************
// CLASS DECLARATIONS
//**************************************************

class QTSSARTSAccessLog : public QTSSRollingLog
{
    public:
    
        QTSSARTSAccessLog();
        virtual ~QTSSARTSAccessLog() {}
    
        virtual char* GetLogName() { return QTSSModuleUtils::GetStringAttribute(sPrefs, "arts_request_logfile_name", sDefaultLogName); }
        virtual char* GetLogDir()  { return QTSSModuleUtils::GetStringAttribute(sPrefs, "arts_request_logfile_dir", sDefaultLogDir); }
        virtual UInt32 GetRollIntervalInDays()  { return sRollInterval; }
        virtual UInt32 GetMaxLogBytes()         { return sMaxLogBytes; }
        virtual time_t WriteLogHeader(FILE *inFile);
};

// ---------------------------------------------------------------------------
// CLASS IMPLEMENTATIONS
// ---------------------------------------------------------------------------

// ****************************************************************************
// QTSSARTSAccessLog -- subclass of QTSSRollingLog
// ****************************************************************************
QTSSARTSAccessLog::QTSSARTSAccessLog() : QTSSRollingLog() 
{
    this->SetTaskName("QTSSARTSAccessLog");
}

time_t QTSSARTSAccessLog::WriteLogHeader(FILE *inFile)
{
    //The point of this header is to record the exact time the log file was created,
    //in a format that is easy to parse through whenever we open the file again.
    //This is necessary to support log rolling based on a time interval, and POSIX doesn't
    //support a create date in files.
    time_t calendarTime = ::time(NULL);
    Assert(-1 != calendarTime);
    if (-1 == calendarTime)
        return -1;

    struct tm  timeResult;
    struct tm* theLocalTime = qtss_localtime(&calendarTime, &timeResult);
    Assert(NULL != theLocalTime);
    if (NULL == theLocalTime)
        return -1;
    
    char tempBuffer[1024] = { 0 };
    qtss_strftime(tempBuffer, sizeof(tempBuffer), "#Log File Created On: %m/%d/%Y %H:%M:%S\n", theLocalTime);
    this->WriteToLog(tempBuffer, !kAllowLogToRoll);
    tempBuffer[0] = '\0';
    
    //format a date for the startup time
    char theDateBuffer[QTSSRollingLog::kMaxDateBufferSizeInBytes] = { 0 };
    Bool16 result = QTSSRollingLog::FormatDate(theDateBuffer, false);
    
    if (result)
    {
        StrPtrLen serverName;
        (void)QTSS_GetValuePtr(sServer, qtssSvrServerName, 0, (void**)&serverName.Ptr, &serverName.Len);
        StrPtrLen serverVersion;
        (void)QTSS_GetValuePtr(sServer, qtssSvrServerVersion, 0, (void**)&serverVersion.Ptr, &serverVersion.Len);
        qtss_sprintf(tempBuffer, sLogHeader, serverName.Ptr , serverVersion.Ptr, 
                            theDateBuffer, sLogTimeInGMT ? "GMT" : "local time");
        this->WriteToLog(tempBuffer, !kAllowLogToRoll);
    }
        
    return calendarTime;
}

//------------------------------------------------------------------------
// CONTROLLER INTERFACE IMPLEMENTATION
//------------------------------------------------------------------------
ARTS_PH_Interface::ARTS_PH_Interface() :
    OSThread()
{
    ev = fdevent_init(4096, FDEVENT_HANDLER_POLL);
    control_state = ARTS_CONTROLLER_STATE_UNSET;
    controlsock = iosocket_init();
    listensock = iosocket_init();
    controllertimeout = 0;
    phid = 0;
    callid = 0;
    listenport = 0;
    co_socket_list = NULL;
    polltimeout =1000;
    stop_events = NULL;
    arts_handle_controller_callbacks(arts_rtsp_reg_handler, 
                                     arts_rtsp_conresp_handler, 
                                     arts_rtsp_conrel_handler, 
                                     arts_rtsp_shutdown_handler, 
                                     arts_rtsp_flush_handler, 
                                     arts_rtsp_loadstatus_handler);
}



ARTS_PH_Interface::~ARTS_PH_Interface()
{
    iosocket_free(controlsock);
    iosocket_free(listensock);
    fdevent_free(ev);
}

#define LogRequest(LEVEL, CID,fmt,...) { \
    if (sLogEnabled && LEVEL <= ARTS_MODULE_DEBUG_LEVEL) { \
        char time_ [100] = { 0 }; \
        time_t t = time (0); \
        strftime(time_, 100, "%F %T", localtime (&t)); \
        LogRequest_ ("%s [%s:%d] %d:%d:%d | " fmt "\n", time_, __FUNCTION__, __LINE__, (CID >> 24), ((CID & 0xFFFFF)>>4), (CID & 0xF), ## __VA_ARGS__); \
    } \
}
void LogRequest_ (const char *fmt, ...)
{
    if(fmt != NULL)
    {
        //OSMutexLocker locker(OS::GetStdLibMutex());
        
        va_list args;
        va_start(args,fmt);
        char tempBuffer[1024] = { 0 };
        ::vsnprintf(tempBuffer, 1024, fmt , args);
        //::vprintf(fmt, args);
        va_end(args);       
        sARTSAccessLog->WriteToLog(tempBuffer, kAllowLogToRoll);       
    }
    
   
}

void    WriteStartupMessage()
{
    
    //format a date for the startup time
    char theDateBuffer[QTSSRollingLog::kMaxDateBufferSizeInBytes];
    Bool16 result = QTSSRollingLog::FormatDate(theDateBuffer, false);
    
    char tempBuffer[1024];
    if (result)
        qtss_sprintf(tempBuffer, "#Remark: Streaming beginning STARTUP %s\n", theDateBuffer);
        
    // log startup message to error log as well.
    if ((result) && (sARTSAccessLog != NULL))
        sARTSAccessLog->WriteToLog(tempBuffer, kAllowLogToRoll);
}

void    WriteShutdownMessage()
{
    
    //log shutdown message
    //format a date for the shutdown time
    char theDateBuffer[QTSSRollingLog::kMaxDateBufferSizeInBytes];
    Bool16 result = QTSSRollingLog::FormatDate(theDateBuffer, false);
    
    char tempBuffer[1024];
    if (result)
        qtss_sprintf(tempBuffer, "#Remark: Streaming beginning SHUTDOWN %s\n", theDateBuffer);

    if ( result && sARTSAccessLog != NULL )
        sARTSAccessLog->WriteToLog(tempBuffer, kAllowLogToRoll);
}


//for dump data from adapter
FILE * arts_open_file()
{
    char template_file[L_tmpnam];
    memset(template_file,0,sizeof(template_file)) ;
    strcpy(template_file, "/tmp/megXXXXXX");  
    char *ifile = mktemp(template_file);
    FILE *fb = fopen(ifile,"wb+");  
    if(fb==NULL){
       qtss_printf("open receive_pkt failed\n");
    }
    else{       
       qtss_printf("%s input open success\n",ifile);
       return fb;
    }
    
    return NULL;
}


static void insert_stopEventsList(int callid,int events,arts_session * sess,int fd)
{
    if(callid <=0 || sess == NULL)
    {
        LogRequest(INFO_ARTS_MODULE, callid,"insert_stopEventList callid:%d",callid);
        return;
     }
     
    event_node_t *newNode=(event_node_t*)malloc(sizeof(event_node_t));
    Assert(newNode!= NULL);
    memset(newNode,0,sizeof(event_node_t));
    
    newNode->next = NULL;
    newNode->callid = callid;
    newNode->events = events;   
    newNode->unregister =1;
    newNode->sess = sess;
    newNode->fd = fd;
    
    LogRequest(INFO_ARTS_MODULE, callid,"insert_stopEventList Node,fd:%d",fd);
   
    
    if(sARTSPHInterface->stop_events == NULL)
    {
        sARTSPHInterface->stop_events = newNode;
        sARTSPHInterface->stop_events->next = NULL;
        return ;
    }else
    {
        event_node_t  * p= sARTSPHInterface->stop_events;
        
        while( p!= NULL && p->next!= NULL) 
        {
            p =(event_node_t *)p->next;
        }
        
         p->next = newNode;   
         return ; 
    }  
    
}

static void del_events_node(int fd)
{
    bool find_sess =0;
    event_node_t * p= sARTSPHInterface->stop_events;
    if(p == NULL ||fd <0)
        return;
    
    event_node_t * prev = p;
    
    while(p)
    {        
        if( p->fd == fd){
            find_sess =1;           
            break;
        }
        prev = p;
        p=(event_node_t *)p->next;
    }
    
    if(find_sess == 0)
    {
        return ;
    }
    
    if(  p == prev )
    {
        sARTSPHInterface->stop_events = (event_node_t*)p->next;
        prev->next = NULL;
        free(prev);
        LogRequest(INFO_ARTS_MODULE, 0,"get event node ,will free it,fd:%d",p->fd);
    }else
    {
        prev->next = p->next;
        p->next= NULL;
        free(p);
        LogRequest(INFO_ARTS_MODULE, 0,"get event node ,will free it,fd:%d",p->fd);
    }
    
}

static void set_unregister(arts_session * sess)
{
    event_node_t * p= sARTSPHInterface->stop_events;
    int find_sess =0;
    
    while(p)
    {
       
       arts_session * cur_sess=(arts_session *)p->sess;  
       if(cur_sess == NULL)
       {
            p = (event_node_t*)p->next;
            continue;    
        }    
        
        if( cur_sess->callid == sess->callid)
        {
            find_sess =1;
            LogRequest(DEBUG_ARTS_MODULE, sess->callid,"get session,we will set_unregister");
            break;
        }  
       p = (event_node_t*)p->next;
    }
    if(p != NULL && find_sess == 1)
        p->unregister = 1;
    
}


void clear_buffer(arts_session *sess)
{

    custom_struct_t *cur_struct = (custom_struct_t *)sess->darwin_custom_struct;
    Assert(cur_struct != NULL);
    ARTS_Get_Packet *sARTSGetPacket= (ARTS_Get_Packet*) cur_struct->receive_pkts_thread;
    if(sARTSGetPacket == NULL)
        return;
    OSMutexLocker lockerBuffer(&sARTSGetPacket->bufferMux); 
    if(sess->rtp_packet_buffer)
    {
        rtp_packet_buffer_type * p = sess->rtp_packet_buffer;
        while( p )
        {
            sess->rtp_packet_buffer = (rtp_packet_buffer_type *)sess->rtp_packet_buffer -> next;
            p->next = NULL;
            
            free(p->pkt_buf);
            free(p);
            
            p=sess->rtp_packet_buffer;            
        }
    }
    
}




void insert_buffers(arts_session *sess,rtp_packet_buffer_type *rtp_packet_buffer)
{
    Assert(sess!= NULL);
    Assert(rtp_packet_buffer != NULL);
   
     if(sess->rtp_packet_buffer == NULL)
     {
        sess->rtp_packet_buffer = rtp_packet_buffer; 
        sess->rtp_packet_buffer->next = NULL;                         
            
     }else            
     {
        
        if(sess->last_rtp_packet != NULL){
            rtp_packet_buffer->next = NULL;
            rtp_packet_buffer_type * p_last = (rtp_packet_buffer_type*)sess->last_rtp_packet;
            p_last->next = rtp_packet_buffer;  
            //LogRequest(DEBUG_ARTS_MODULE, sess->callid,"insert after sess->last_rtp_packet");
        }          
        else
        {
     
            rtp_packet_buffer_type *p = sess->rtp_packet_buffer;
            rtp_packet_buffer_type *prev=NULL;
            while( NULL != p->next && rtp_packet_buffer->timestamp >= p->timestamp)
            {
                prev=p;
                p=(rtp_packet_buffer_type *)p->next;    
            }
                
            if(p == sess->rtp_packet_buffer)                
            {
                if(rtp_packet_buffer->timestamp < p->timestamp){
                    rtp_packet_buffer->next = sess->rtp_packet_buffer;
                    sess->rtp_packet_buffer = rtp_packet_buffer ;   
                }else {
                    rtp_packet_buffer->next = sess->rtp_packet_buffer->next;
                    sess->rtp_packet_buffer->next = rtp_packet_buffer;
                }
                                      
            }else if( p->next == NULL && rtp_packet_buffer->timestamp >= p->timestamp)
            {
                rtp_packet_buffer->next = p->next;
                p->next = rtp_packet_buffer;                                    
            }
            else
            {
                rtp_packet_buffer -> next = prev->next;
                prev->next= rtp_packet_buffer;
            }
        }         
    }  
    //if(sess->transport_type == qtssRTPTransportTypeMPEG2)
    {
        sess->last_rtp_packet  = rtp_packet_buffer;  
       // LogRequest(DEBUG_ARTS_MODULE, sess->callid,"sess->last_rtp_packet:%x",sess->last_rtp_packet); 
    }   
}


int64_t GetBufferLastTimestamp(arts_session *sess)
{
    Assert(sess!= NULL)
    if(sess->rtp_packet_buffer == NULL)
    return 0;
    else
    {
        rtp_packet_buffer_type *p = sess->rtp_packet_buffer;
        while(p->next !=NULL){
            p=(rtp_packet_buffer_type *)p->next;          
         }
            
        return p->timestamp;
    }
}


void set_need_idel_time(int idel_time,arts_session *sess)
{
    if(sess!= NULL && sess->darwin_custom_struct!=NULL)
    {
        custom_struct_t * cur_struct = (custom_struct_t *)sess->darwin_custom_struct;
        ARTS_Get_Packet *sARTSGetPacket = (ARTS_Get_Packet *)cur_struct->receive_pkts_thread;
        if(sARTSGetPacket != NULL)
        { 
            sARTSGetPacket ->needIdelTime = idel_time;
        }          
        
    }
}


void refresh_socket_list(bool cleanall)
{
    co_socket_t *p = sARTSPHInterface->co_socket_list;
    co_socket_t *prev = p;
    while(p)
    {
        if(p->used == true || cleanall==true)
        {
            //prev = p;          
            co_socket_t *q=p;
            if(prev == p)
            {
                sARTSPHInterface->co_socket_list =(co_socket_t *) p->next;
                p= sARTSPHInterface->co_socket_list;
                prev = p;
            } else
            {
                prev->next = p->next;
                p=(co_socket_t *)p->next;
            }   
                        
            q->next = NULL;
            free(q);         
        }
        
    }  
    
}


void stop_getpkts_thread(arts_session*sess)
{
       
     if(sess == NULL)
        return;     
     if((sess)->darwin_custom_struct != NULL)
     {
        custom_struct_t *custom_struct = ( custom_struct_t *)(sess)->darwin_custom_struct;
        if( custom_struct->receive_pkts_thread!= NULL)
        {        
            ARTS_Get_Packet *sARTSGetPacket = (ARTS_Get_Packet *) custom_struct->receive_pkts_thread;
            delete sARTSGetPacket;
            custom_struct->receive_pkts_thread= NULL;           
            LogRequest(INFO_ARTS_MODULE, sess->callid,"stop thread");
            
        }
     }
}

static void sendAnnouce(arts_session * sess)
{
    if(sess == NULL )
    return;
    UInt32 err=0;
    custom_struct_t * custom_struct = (custom_struct_t*)sess->darwin_custom_struct;
    //LogRequest(DEBUG_ARTS_MODULE,sess->callid,"Entry,custom_struct:%x,custom_struct->supportPTS:%d",custom_struct,custom_struct->supportPTS);
    if(custom_struct != NULL)
    {
        RTSPSessionInterface * theRTSPSess =(RTSPSessionInterface *)custom_struct->OwnRTSPSessionObj;
        if(theRTSPSess == NULL)
            return;
            
        RTSPResponseStream *fOutputStream = theRTSPSess->GetOutputStream();
        char annReq[2048]={'\0'};
        
        if(custom_struct->supportOtherChannel==true)
        {
            sprintf(annReq,"ANNOUNCE %s RTSP/1.0\r\nCSeq: %d\r\nSession: %s\r\nX-notice: EOS\r\n\r\n",custom_struct->uri,custom_struct->cseq+1,custom_struct->sessionID); 
        }else if (custom_struct->supportPTS == true)
        {
            sprintf(annReq,"SET_PARAMETER %s RTSP/1.0\r\nCSeq: %d\r\nSession: %s\r\nServer: ARTSRTSPStreamingServer\r\nx-Info:\"CLOSE\"\r\nx-Reason: \"END\"\r\n\r\n",custom_struct->uri,custom_struct->cseq+1,custom_struct->sessionID);   
            //theRTSPSess->SetAdapterClose(true);     
        }
        //LogRequest(DEBUG_ARTS_MODULE,sess->callid,"%s",annReq);
        
        if(strlen(annReq)>0)
        {
            StrPtrLen  annReqStr(annReq,strlen(annReq));            
            fOutputStream->Put(annReqStr);
            err = fOutputStream->Flush();
            Assert( err == QTSS_NoErr);
        }
        
        if(custom_struct->supportOtherChannel == true)
        {
            custom_struct->supportOtherChannel = false;
            LogRequest(DEBUG_ARTS_MODULE, sess->callid,"sendAnnounceResponse");
        }else  if( custom_struct->supportPTS == true)
        {
            custom_struct->supportPTS =false;
            LogRequest(DEBUG_ARTS_MODULE, sess->callid,"send SET_PARAMETER Response"); 
        }
    }
   
   
    
}

int get_packet(char *pkt_buf,int total_len ,void *isess)
{
   /*
    if(inputfile!=NULL)
    {
        //read(transport_fd, send_buf, packet_size);
        int real_len=fread(pkt_buf,sizeof(char),7*188,inputfile);
        return real_len;
    }*/
    
    Assert(isess!=NULL);
    Assert(pkt_buf!=NULL);
    arts_session * sess = (arts_session *)isess;
    custom_struct_t * custom_struct = (custom_struct_t*)sess->darwin_custom_struct;
    timeout_ev_t *curSendEv = (timeout_ev_t *)custom_struct->sendEv;
    if(curSendEv->pause == true)
    {
       
        return 0;
    }
    if(custom_struct == NULL)
        return -1;
    char *buf = pkt_buf;
    int pkt_num =0;
    
    if(total_len <=0)
        return 0;
    int real_len =0;    
    LogRequest(DEBUG_ARTS_MODULE, sess->callid,"sess->rtp_packet_buffer_len:%d,total_len:%d",sess->rtp_packet_buffer_len,total_len);
       
    int left_len = ARTSMIN(total_len,TS_TCP_PACKET_SIZE); 
    
    if(custom_struct->seek == true && custom_struct->seek_start_dts >0)
    {
        custom_struct->seek = false;
    }
    ARTS_Get_Packet *sARTSGetPacket = (ARTS_Get_Packet *)custom_struct->receive_pkts_thread;
    
    
    while(left_len&& sess->rtp_packet_buffer_len >0)
    {
       
        rtp_packet_buffer_type *cur = sess->rtp_packet_buffer;
        if(cur == NULL)
            break;
                   
        int tmp1= ARTSMIN(TS_TCP_PACKET_SIZE,left_len);
        
        int real_num = ARTSMIN(tmp1,cur->pkt_len); 
        
        //LogRequest(DEBUG_ARTS_MODULE, sess->callid,"cur_pkt_len:%d,real_num:%d",cur->pkt_len);
        
        left_len -= real_num;   
                                        
        memcpy(buf,cur->pkt_buf,real_num);
        real_len += real_num;
        buf+= real_num;
        cur->pkt_len -= real_num;
                    
        if (cur->pkt_len>0)
        {
            char tmp_pkt[TS_TCP_PACKET_SIZE];
            memcpy(tmp_pkt,cur->pkt_buf+real_num,cur->pkt_len);
            memcpy(cur->pkt_buf,tmp_pkt,cur->pkt_len);
        }
                   
        
        pkt_num = real_len/TS_PACKET_SIZE;                         
        //LogRequest(DEBUG_ARTS_MODULE, sess->callid,"real_len:%d,pkt_num:%d",real_len,pkt_num);           
                       
        
        if(cur->pkt_len ==0)  
        {  
            int64_t cur_duration = GetFrameDuration(sess);
            custom_struct->buf_duration -= cur_duration; 
                                                
                          
            if(sARTSGetPacket != NULL)
            {                                                 
                OSMutexLocker lockerBuffer(&sARTSGetPacket->bufferMux); 
                if(sess->rtp_packet_buffer == NULL)
                {
                    return 0;
                }
                                          
                sess->rtp_packet_buffer =(rtp_packet_buffer_type *) cur->next; 
                LogRequest(DEBUG_ARTS_MODULE, sess->callid,"this packets PCR:%u,cur_duration:%d",cur->timestamp,cur_duration);
                cur->next = NULL;
                free(cur->pkt_buf);
                free(cur);
                sess->rtp_packet_buffer_len -= 1;        
            }else
            {
                sess->rtp_packet_buffer =(rtp_packet_buffer_type *) cur->next; 
                LogRequest(DEBUG_ARTS_MODULE, sess->callid,"this packets PCR:%u,cur_duration:%d",cur->timestamp,cur_duration);
                cur->next = NULL;
                free(cur->pkt_buf);
                free(cur);
                sess->rtp_packet_buffer_len -= 1;     
            }    
        }  
                     
        if(pkt_num >= 7 )
        {                        
               break;         
        }
    }                                
           
    
end:
    if(custom_struct->ofd !=NULL)
    {
        fwrite(pkt_buf,sizeof(char),real_len,custom_struct->ofd);
    }                            
    return real_len;         
}


void free_custom_struct(arts_session * sess,bool * need_free_sess)
{

     if(inputfile != NULL)
     {
        fclose(inputfile);
        inputfile  = NULL;
     }    
          
       
     if(sess == NULL)
     {
        LogRequest(INFO_ARTS_MODULE, 0,"session is null");
        return ;
     }   
     
     // LogRequest(INFO_ARTS_MODULE, 0,"sess->darwin_custom_struct=%x",sess->darwin_custom_struct);
     if(sess->darwin_custom_struct != NULL)
     {
        stop_getpkts_thread(sess);
    
        custom_struct_t * custom_struct = (custom_struct_t *)sess->darwin_custom_struct;
        
        if( custom_struct->RTSPSessionObj != NULL )
        {
            RTSPSession * theRTSPSess = (RTSPSession *) custom_struct->RTSPSessionObj;
            Assert(theRTSPSess!= NULL); 
            LogRequest(INFO_ARTS_MODULE, 0,"ARTSMOdule cleanup,obj:%x\n",custom_struct->RTSPSessionObj);       
            //theRTSPSess->CleanupRequest();  
            //theRTSPSess->Signal(Task::kKillEvent);
            delete theRTSPSess;//use delete install of killsignal dueto  first one can validate at once
            custom_struct->RTSPSessionObj = NULL;        
        }     
        
                
           
        if(custom_struct->sendEv!= NULL)
        {
            
            free(custom_struct->sendEv);
            custom_struct->sendEv = NULL;
        }
        
        if(custom_struct->tsctx != NULL)
        {
            MpegTSContext *ts = (MpegTSContext *)custom_struct->tsctx;
            delete_ts_prg(ts);
            delete_sevice(ts);
            free(custom_struct->tsctx);
            custom_struct->tsctx = NULL;
        }
       
         if(custom_struct->ifd !=NULL)
        {   
            fclose(custom_struct->ifd);
            custom_struct->ifd= NULL;
        }
        if(custom_struct->ofd!=NULL)
        {
            fclose(custom_struct->ofd);
            custom_struct->ofd =NULL;
        }  
      
        free(sess->darwin_custom_struct);
        sess->darwin_custom_struct = NULL;        
        LogRequest(INFO_ARTS_MODULE, sess->callid,"free sess->darwin_custom_struct=%x",sess->darwin_custom_struct);
    }
    
      refresh_socket_list(false);
}

static void insert_sess_buffer(arts_session *sess,uint8_t *buf,int buf_size,int64_t timestamp,bool start,bool end)
{
     LogRequest(DEBUG_ARTS_MODULE, sess->callid,"insert buffer:%d,timestamp:%u,start:%d,end:%d",buf_size,timestamp,start,end);
    
    if(buf == NULL || buf_size <=0 || sess == NULL)
        return;
    rtp_packet_buffer_type *rtp_packet_buffer =(rtp_packet_buffer_type *) malloc(sizeof(rtp_packet_buffer_type));
    memset(rtp_packet_buffer,0,sizeof(rtp_packet_buffer_type));
    
	rtp_packet_buffer->pkt_buf = (char*)malloc(buf_size);
	rtp_packet_buffer->pkt_len = buf_size;
	rtp_packet_buffer->start = start;
	rtp_packet_buffer->timestamp =timestamp;
	Assert(rtp_packet_buffer->pkt_buf !=NULL);
	memcpy(rtp_packet_buffer->pkt_buf,buf,buf_size);
	custom_struct_t *custom_struct = (custom_struct_t *)sess->darwin_custom_struct;
	Assert(custom_struct != NULL) ;
	
	ARTS_Get_Packet *sARTSGetPacket = (ARTS_Get_Packet *)custom_struct->receive_pkts_thread; 
	Assert(sARTSGetPacket != NULL);
	    
	OSMutexLocker lockerBuffer(&sARTSGetPacket->bufferMux);
	insert_buffers(sess,rtp_packet_buffer); 
	sess->rtp_packet_buffer_len ++;
	
}

static void *get_last_pcr(arts_session * sess,MpegTSContext *ts)
{
    int64_t last_pcr=0;
    rtp_packet_buffer_type * p = sess->rtp_packet_buffer;
    rtp_packet_buffer_type * q = NULL;
    
    while(p )
    {
        
        if(p->next)
        {
           rtp_packet_buffer_type *pnext= (rtp_packet_buffer_type *)p->next;           
           if(pnext->start == true){
                last_pcr =p->timestamp; 
                LogRequest(DEBUG_ARTS_MODULE, sess->callid,"This PKt is pcr,ts:%u,last_pcr:%u",pnext->timestamp,last_pcr);
                q =p;
           }
         }
        else if(p->next == NULL && p->start == true && p ==sess->rtp_packet_buffer)
        {
            q= sess->rtp_packet_buffer;
        }
        
        p =( rtp_packet_buffer_type *)p->next;
    }
    
    //modify the following pkts timestamp    
    
   if(q!=NULL)
   {
     ts->cur_pcrMS = last_pcr;
     rtp_packet_buffer_type * qq =(rtp_packet_buffer_type*) q->next;
     while(qq!= NULL)
     {
        LogRequest(DEBUG_ARTS_MODULE, sess->callid,"modify timestamp from %u to %u",qq->timestamp,last_pcr);
        qq->timestamp = last_pcr;
        qq = (rtp_packet_buffer_type*)qq->next;        
     }
   }
        
        
    return q;
}



 int delete_pcr_pkt(int callid,MpegTSContext *ts)
{

    //OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex); 
    
    
    arts_session *sess = arts_session_find(callid);            
    if(sess ==NULL )
         return QTSS_RequestFailed; 
   
   if(sess->rtp_packet_buffer == NULL || sess->rtp_packet_buffer_len <=0)
        return 0;
    custom_struct_t * custom_struct = (custom_struct_t *)sess->darwin_custom_struct;
    if(custom_struct != NULL)
     custom_struct->del_pcr_flag = true;    
        
    rtp_packet_buffer_type * p= (rtp_packet_buffer_type *)get_last_pcr(sess,ts);
    rtp_packet_buffer_type *q = NULL;
    
    if(p == NULL)
        return 0;
    if(p == sess->rtp_packet_buffer)
    {
        q= p;
        q->next = NULL;
        sess->rtp_packet_buffer = NULL;
        sess->rtp_packet_buffer_len = 0;
        free(q->pkt_buf);
        free(q);
    }else
    {
        q = (rtp_packet_buffer_type *)p->next;
        p ->next = q->next;
        q->next = NULL;
        free(q->pkt_buf);
        free(q);
        sess->rtp_packet_buffer_len --;
    }
    
   return 0;
}

int insert_one_pkt(MpegTSContext *ts,int callid,unsigned char *buf,int buf_size,int64_t pcr,bool is_pes,bool a_flag,bool v_falg,bool sec2_start,bool sec2_end)
{
    arts_session * sess =arts_session_find(callid);
   Assert(sess!= NULL);
   bool finish = false;
   bool start = false;
   bool real_end=false;
   
   //when delete one pcr pkts from sess->rtp_packet_buffer, modify ts->sess_pkt_timestamp immediatily
   custom_struct_t * custom_struct = (custom_struct_t *)sess->darwin_custom_struct;
   if(custom_struct != NULL && custom_struct->del_pcr_flag == true)
   {
       ts->sess_pkt_timestamp = ts->cur_pcrMS;
       custom_struct->del_pcr_flag =false;
   }
   LogRequest(DEBUG_ARTS_MODULE, sess->callid,"Entry,ts->buf_len:%d,pcr:%u",ts->buf_len,pcr);
   
   //new pcr pkt,need fresh ts->sess_pkt_timestamp
  
   
   while(true)
   {
   
        if(ts->buf_len >= TS_TCP_PACKET_SIZE || pcr >=0 )  
        {
            if(pcr>=0 && finish ==1)
            {
                start = true;
                real_end = true;
            }
            insert_sess_buffer(sess,ts->buf,ts->buf_len,ts->sess_pkt_timestamp,start,real_end);  
            //fwrite(ts->buf,sizeof(char),ts->buf_len,testfd);     
            ts->buf_len =0;
            
            if(start == true)
            {
                //LogRequest(DEBUG_ARTS_MODULE, sess->callid,"start = true ,break");
                break;
            }
            
        }
        if(ts->cur_pcrMS >0)
            ts->sess_pkt_timestamp = pcr >1 ?pcr:ts->cur_pcrMS;
        memcpy(ts->buf+ts->buf_len,buf,buf_size);
        ts->buf_len += buf_size;        
        finish =1;
        
        if(pcr <0)
        {
            //LogRequest(DEBUG_ARTS_MODULE, sess->callid,"pcr<0 ,break")
            break;
        }
               
    }
    return 0;
}

static int  handle_RTP_Pkt(arts_session * cur_sess,int callid,custom_struct_t * custom_struct,rtp_packet_buffer_type * rtp_packet_buffer)
{
    int valid_pkt =true;
    if(rtp_packet_buffer == NULL || custom_struct == NULL)
        return 0;
        
    QTSS_PacketStruct thePacket;
    thePacket.packetData = rtp_packet_buffer->pkt_buf;
   
    Assert(cur_sess!=NULL); 
    
    UInt32* theTimeStampP = (UInt32*)thePacket.packetData;          
    UInt32 theTimeStamp = ntohl(theTimeStampP[1]);                
                
            
    UInt8* padding_lenP = (UInt8*)(thePacket.packetData +rtp_packet_buffer->pkt_len-1);
    UInt8  padding_len=padding_lenP[0];          
            
    UInt32* dtsP =(UInt32*) ((UInt8*) ( thePacket.packetData + rtp_packet_buffer->pkt_len - padding_len ));                     
    UInt32 theDts = ntohl(dtsP[0]);

    UInt16* theSeqNumP = (UInt16*)thePacket.packetData;
           
    UInt16 theSeqNum = ntohs(theSeqNumP[1]);
            
    //rtp_packet_buffer->timestamp =( ((SInt64)(theTimeStamp) * (SInt64) 1000) /
    //                         ( (rtp_packet_buffer->pkt_str==2) ? (SInt64)(sess->rtp_audio_clock_rate):
    //                              (SInt64)(sess->rtp_video_clock_rate)));  
                
                
    rtp_packet_buffer->timestamp = theDts;  
                
    if(custom_struct->seek== true & custom_struct->play_responsed == 0)
    {
        LogRequest(INFO_ARTS_MODULE, callid,"noplayresponse,and dts:%u ,drop it",theTimeStamp,rtp_packet_buffer->timestamp);
        free(rtp_packet_buffer->pkt_buf);
        free(rtp_packet_buffer);
        valid_pkt = false;
        return valid_pkt;
                    
    }
                              
              
    // seek low  when theTimeStamp < sess->rtp_video_timestamp,drop it
    if(  (cur_sess->rtp_video_timestamp <cur_sess->rtp_last_video_timestamp &&  cur_sess->rtp_video_timestamp>0) ||  
            (cur_sess->rtp_audio_timestamp<cur_sess->rtp_last_audio_timestamp && cur_sess->rtp_audio_timestamp >0))
    {
        if(theDts >= custom_struct->seek_start_dts && custom_struct->seek_start_dts >0)
        {
            goto end;
        }
                                                
        if( ((theTimeStamp <cur_sess->rtp_video_timestamp || theTimeStamp > cur_sess->rtp_last_video_timestamp)&& rtp_packet_buffer->pkt_str == 3 ) ||
           ((theTimeStamp <cur_sess->rtp_audio_timestamp || theTimeStamp > cur_sess->rtp_last_audio_timestamp) && rtp_packet_buffer->pkt_str == 2 ) )
        {
            LogRequest(INFO_ARTS_MODULE, callid,"seek low the rtptimestamp is %d,and dts:%u ,drop it",theTimeStamp,rtp_packet_buffer->timestamp);
            free(rtp_packet_buffer->pkt_buf);
            free(rtp_packet_buffer);
            valid_pkt = false;
            return valid_pkt;    
        }
    }
                                    
end:            
    //seek high
    if(cur_sess->rtp_video_timestamp >cur_sess->rtp_last_video_timestamp || 
            cur_sess->rtp_audio_timestamp > cur_sess->rtp_last_audio_timestamp)
    {
        if(theTimeStamp <cur_sess->rtp_video_timestamp && rtp_packet_buffer->pkt_str == 3 || 
                            theTimeStamp <cur_sess->rtp_audio_timestamp && rtp_packet_buffer->pkt_str == 2)
        {
            LogRequest(INFO_ARTS_MODULE, callid,"seek high the rtptimestamp is %d,and dts:%u ,drop it",theTimeStamp,rtp_packet_buffer->timestamp);
            free(rtp_packet_buffer->pkt_buf);
            free(rtp_packet_buffer);
            valid_pkt = false;
            return valid_pkt;
        }
    }
                    
    if(custom_struct->seek_start_dts == 0 && custom_struct->seek == true)
    {
        custom_struct->seek_start_dts = theDts;
        LogRequest(DEBUG_ARTS_MODULE, callid," new start dts:%"_64BITARG_"d",custom_struct->seek_start_dts);
    }          
          
    QTSS_TimeVal CurrentTime = QTSS_Milliseconds();   
    LogRequest(DEBUG_ARTS_MODULE, callid, "current_time:%"_64BITARG_"d,type = %c,buffer_len  = %d ,"
                   " Thetimestamp = %u ,dts = %u,seqNum=%u,pkt_len:%d" ,CurrentTime,TYPE_TO_C(rtp_packet_buffer->pkt_str),
                   cur_sess->rtp_packet_buffer_len,theTimeStamp,theDts,theSeqNum,rtp_packet_buffer->pkt_len);
   return valid_pkt; 
}


static bool isValidate_pkt(arts_session * sess,uint8_t *ptr,int callid,UInt32* pktLen)
{
    if(ptr == NULL)
        return false;
    Assert(sess!=NULL);  
     
    custom_struct_t * custom_struct = NULL; 
    bool error_indicator = false;
    bool priority_flag=false;
    bool is_start=false;
    int64_t timestampInMS=-1;  
    
    
    int64_t  PCR = GetMPEG2PCR(ptr,pktLen);  
    if(PCR >-1)
    {
        timestampInMS = PCR/27/1000;
        LogRequest(DEBUG_ARTS_MODULE, callid,"pcr-ms:%d",timestampInMS);
    }  
    
    
    custom_struct = (custom_struct_t *)sess->darwin_custom_struct; 
    
    LogRequest(DEBUG_ARTS_MODULE, callid,"ptr[0]:%X,ptr[1]:%x",ptr[0],ptr[1]);
    if(ptr[0]== 0x47)
    {                      
          if( (ptr[1]&0x80) !=0)
                error_indicator =true;
          if( (ptr[1]&0x20) != 0)
                priority_flag =true;
          if( (ptr[1]&0x40) !=0 )
                is_start =true;               
     }        
     
     if( error_indicator == true || priority_flag == true)
     {                       
            ptr[1]= (ptr[1] &0x5f);
           
            custom_struct->seek_start = true; 
            sess->mpeg2_start_time = 0;
            LogRequest(DEBUG_ARTS_MODULE, callid,"sess->mpeg2_start_time:%"_64BITARG_"d",sess->mpeg2_start_time);
            LogRequest(DEBUG_ARTS_MODULE, callid,"packet[1]:%X",ptr[1]);
            error_indicator = false;
            priority_flag = false;
            MpegTSContext *ts=( MpegTSContext *)(custom_struct->tsctx);
            ts->last_pcr =-1;
       } 
            
      if( (custom_struct->seek_start_dts<=0 )&& custom_struct->seek == true)
        {
           if( custom_struct->seek_start ==false)
           {
              LogRequest(DEBUG_ARTS_MODULE, callid,"the PCR is %u,drop it", timestampInMS);
              return false;
            }
        }
 
               
    if(timestampInMS>0 && custom_struct->seek_start_dts ==0 &&custom_struct->seek== true && custom_struct->seek_start==true)
    {                  
        custom_struct->seek_start_dts = timestampInMS;
        LogRequest(INFO_ARTS_MODULE, callid,"Get the new start,PCR:%u",timestampInMS);  
        custom_struct->seek_start = false;
        if(custom_struct != NULL && strlen(custom_struct->rangeHeader_global)>0)
        {   
            sess->head.state &= ~ARTS_CALL_STATE_PLAY_CMD_SENT; 
            LogRequest(DEBUG_ARTS_MODULE,callid,"will send Play");    
            send_play_request(callid);
            return false;  
        }         
    }  
    if( custom_struct->seek_start_dts ==0)
    {
        LogRequest(DEBUG_ARTS_MODULE, callid,"the PCR is %u,drop it", timestampInMS);
        return false;
    }
 
    return true;         
}

static int handle_TS_Pkt_Ipqam(arts_session * sess,int callid,custom_struct_t * custom_struct,char * l_buf,int in)
{
    int valid_pkt = true;
    int ret =0;
    MpegTSContext *ts=( MpegTSContext *)(custom_struct->tsctx);
    UInt32 pktLen = in;
    unsigned char * pkt =(unsigned char*) l_buf;
    
  
    Assert(sess!= NULL);
    
    while(pktLen >= TS_PACKET_SIZE)
    { 
           
        int pid =-1;             
        int64_t pcr=-1;
        int renew_bat = 0;
        int cc =0;
        bool end = false;
        
        
        if(custom_struct->seek == true)
        {
            if(isValidate_pkt(sess,pkt,callid,&pktLen)== false)
            {
                pktLen -= TS_PACKET_SIZE; 
                pkt += TS_PACKET_SIZE;               
                ts->mux_pos += TS_PACKET_SIZE; 
                continue;                
            }else
            {
                ts->cur_pcrMS = custom_struct->seek_start_dts;
                ts->sess_pkt_timestamp = ts->cur_pcrMS;
            }
                 
        }
         
        
        //LogRequest(DEBUG_ARTS_MODULE, callid,"before handle_packet,cur_pcr:%d,last_pcr:%d",ts->cur_pcrMS,ts->last_pcr);
        //cc=handle_packet(ts, pkt,&pid,&pcr,NULL,NULL,callid);  
        //LogRequest(DEBUG_ARTS_MODULE, callid,"after handle_packet,cur_pcr:%d,last_pcr:%d",ts->cur_pcrMS,ts->last_pcr);
         
         
        if(pid == PAT_PID)
        {
            add_service(ts,callid);
            write_new_pat(ts,pid,callid);
            renew_bat =1;
        }                     
       
        ret=insert_pkts(ts,pcr,callid);
        if(ret != QTSS_NoErr)
            return ret;
              
        if(pcr >-1)
        {
            end = true;
        }
        
        //LogRequest(DEBUG_ARTS_MODULE, callid,"renew_bat:%d,ts->pat_copy:%d",renew_bat,ts->pat_copy);
        if (renew_bat == 0 && (ts->pat_copy == 0 || (ts->pat_copy == 1&& pid !=0x00)))
        {       
           
            ret=insert_one_pkt(ts,callid,pkt,TS_PACKET_SIZE,-1,false,false,false,false,false);
            
             //new-insert-method-start             
            //ret=insert_one_pkt(ts,callid,pkt,TS_PACKET_SIZE,pcr);
            //new-insert-method-end
         }
        if(ret != QTSS_NoErr)
            return ret;
       // if(pid == ts->pcr_pid)
        //    ts->counter =cc;
        
        //new-insert-method-start     
         
        /*     
        if(pcr>0)
        {
            ts->pcr_pkts_count = 0;  
            ts->need_pkts_num =0;
         } 
         */
        //new-insert-method-end
         
        if(ts->last_pcr>=0)
            modify_count(ts);
        
       
        pktLen -= TS_PACKET_SIZE; 
        pkt += TS_PACKET_SIZE;               
        ts->mux_pos += TS_PACKET_SIZE; 
        //new-insert-method start
        //ts->cur_pcrMS = ARTSMAX(ts->cur_pcrMS,ts->last_pcr);   //new-insert-method   end  
        LogRequest(DEBUG_ARTS_MODULE, callid,"ts->cur_pcrMs:%d",ts->cur_pcrMS);
    }   
    
   
    if(sess->rtp_packet_buffer_len >0 && sess->rtp_packet_buffer!= NULL)
    {
        int64_t duration = ts->cur_pcrMS - sess->rtp_packet_buffer->timestamp;
        if(duration > 3000)
        {
            custom_struct->buf_duration = duration;
            LogRequest(DEBUG_ARTS_MODULE, callid,"buf duration:%u",custom_struct->duration);
        }
    }   
    
   return 0;     
}


int64_t getLastPts(rtp_packet_buffer_type * rtp_buf,custom_struct_t * custom_struct)
{
    if(custom_struct == NULL)
    return -1;
    /*
    int64_t offset=0;
    if(rtp_buf == NULL)
        return -1;
    rtp_packet_buffer_type * cur = rtp_buf;
    while(cur!= NULL)
    {        
        if(cur->pts>=0)               
           break;
                      
        offset +=  cur->pkt_len;      
        cur = (rtp_packet_buffer_type*)cur->next;
    }
  */
    //if(cur == NULL)
        return custom_struct->last_keyframe_pts;
    //else
        // return custom_struct->offset <= offset ? custom_struct->last_keyframe_pts : cur->pts;
    //    return cur->pts;
   
    
   // return custom_struct->last_keyframe_pts;;
}
rtp_packet_buffer_type * newRtpBuf(char * buffer,int len,int stream_type)
{
    char *first_packet = (char *) malloc(len);
    Assert(first_packet != NULL);
    memcpy(first_packet,buffer,len);           
            
    rtp_packet_buffer_type *rtp_packet_buffer =(rtp_packet_buffer_type *) malloc(sizeof(rtp_packet_buffer_type));
    memset(rtp_packet_buffer,0,sizeof(rtp_packet_buffer_type));
    rtp_packet_buffer->pkt_buf = first_packet;           
    rtp_packet_buffer->pkt_str = stream_type;
    rtp_packet_buffer->pkt_len = len ;
    rtp_packet_buffer->next = NULL;
    rtp_packet_buffer->start = false;
      
    rtp_packet_buffer->timestamp =0;
    return rtp_packet_buffer;
}

int64_t getcurTs(int64_t timestampInMS,custom_struct_t * custom_struct)
{
    if( timestampInMS >0)
        custom_struct ->last_recv_PCR = timestampInMS;            
            
    return  ARTSMAX(timestampInMS,custom_struct ->last_recv_PCR); 
}


QTSS_Error insertPktInBuf(arts_session * cur_sess,rtp_packet_buffer_type * rtp_packet_buffer)
{

    if(cur_sess == NULL || rtp_packet_buffer  == NULL)
        return QTSS_NoErr;
        
    if(cur_sess->transport_type == qtssRTPTransportTypeMPEG2)
    {
        LogRequest(DEBUG_ARTS_MODULE, cur_sess->callid, "current_time:%"_64BITARG_"d,type = %c,buffer_len  = %d ,"
                   "PCR: %"_64BITARG_"d,pkt_len:%d,Pts:%"_64BITARG_"d" ,QTSS_Milliseconds(),TYPE_TO_C(rtp_packet_buffer->pkt_str),
                   cur_sess->rtp_packet_buffer_len,rtp_packet_buffer ->timestamp,rtp_packet_buffer->pkt_len,rtp_packet_buffer->pts);
    }
    custom_struct_t * custom_struct= (custom_struct_t *)cur_sess->darwin_custom_struct;
    Assert(custom_struct != NULL);
    ARTS_Get_Packet *sARTSGetPacket = (ARTS_Get_Packet *)custom_struct->receive_pkts_thread;
    rtp_packet_buffer_type *p = (rtp_packet_buffer_type *)cur_sess->rtp_packet_buffer;
    int64_t duration = 0;
    if(p!= NULL)
        duration = rtp_packet_buffer->timestamp  - p->timestamp;
               
    // LogRequest(DEBUG_ARTS_MODULE, cur_sess->callid,"start insert buffer,time:%"_64BITARG_"d,duration:%"_64BITARG_"d",QTSS_Milliseconds(),duration);
    if (sARTSGetPacket != NULL)
    {
        OSMutexLocker lockerBuffer(&sARTSGetPacket->bufferMux);
        insert_buffers(cur_sess,rtp_packet_buffer);             
        cur_sess->rtp_packet_buffer_len++;
    }
                
    if( cur_sess->rtp_packet_buffer != NULL && duration >= MAXBUFFERDURATION )
    {
        custom_struct->buf_duration = duration;                   
        LogRequest(DEBUG_ARTS_MODULE, cur_sess->callid,"buf_duration:%u",custom_struct->buf_duration);                  
                   
    }
               
    return QTSS_NoErr;  
    
}

static bool  isValidateSEI(char * l_buf,int in)
{
    char *ptr = l_buf;
    if(ptr == NULL)
    return false;
    LogRequest(DEBUG_ARTS_MODULE,0,"ptr[5]:%x,ptr[1]:%x",ptr[5] ,ptr[1]);
    if((ptr[5]== 0x00 || ptr[5]== 0x02 || ptr[5]== 0x42) && ((ptr[1] &0x40)!=0) )
    {
        LogRequest(DEBUG_ARTS_MODULE,0,"ptr[5]:%x,ptr[1]:%x",ptr[5] ,ptr[1]);
        return true;
    }
    return false;
}



static int handle_TS_Pkt_PTS(arts_session *cur_sess,int callid,char * l_buf,int in)
{
    QTSS_TimeVal timestampInMS;
    SInt64 PCR = -1,tmpPCR =-1;
    
    UInt32 pktLen =in;
    char* ptr =l_buf;
    char *lastKeyframe = ptr;
    bool error_indicator =false;
    bool priority_flag =false;
    bool is_start=false;
                
    SInt64 PTS =-1,lastPTS=-1;
    int offset =0;
    bool drop_flag =false;
    int64_t dts = -1;
    bool seek_flag = false;
    char tmp_buf[8*TS_PACKET_SIZE];
      
    custom_struct_t * custom_struct = (custom_struct_t *)cur_sess->darwin_custom_struct;
    int stream_type = 1;
    while(pktLen >= TS_PACKET_SIZE)
    {  
        PTS = -1;
        tmpPCR =-1;
        dts =-1;
                    //tmpPCR = GetMPEG2PCR(ptr, &pktLen,&PTS,&(custom_struct->ts));
        MpegTSContext*ts = (MpegTSContext*)custom_struct->tsctx;
        seek_flag = false;
        //seek_flag = (custom_struct->pause & custom_struct->last_keyframe_pts == -1);
        if(custom_struct->first_pts <0 && (custom_struct->seek==true && custom_struct->seek_start == true) || custom_struct->seek == false)
        {
            seek_flag = true;
            LogRequest(DEBUG_ARTS_MODULE, cur_sess->callid,"first_pts :%d,seek_flag:%d",custom_struct->first_pts,seek_flag);
        }
        
        /*
        if(custom_struct->seek== true && custom_struct->seek_start_dts == 0 )
        {
            seek_flag = true;
            LogRequest(DEBUG_ARTS_MODULE, cur_sess->callid,"seek mode,seek_flag:%d",seek_flag);
        }*/
        
        dts=handle_pkt_simple(ts,(unsigned char*)ptr,TS_PACKET_SIZE,&tmpPCR,&PTS,seek_flag);
        
        if(ptr[5]==0 && ptr[0]==0x47 && ptr[1]== 0x40)
        {
            add_service(ts,0);
        }
        if(tmpPCR>-1)
        {
            LogRequest(DEBUG_ARTS_MODULE, cur_sess->callid,"PCR-MS:%u",tmpPCR);
        }
        if(tmpPCR >-1 && PCR ==-1)
        {
            PCR = tmpPCR;
        } 
                  
                    // get timestamp and set some param
        if(PCR != -1)
       //if(dts!=-1)
        {
            timestampInMS = PCR;     
           //timestampInMS= dts/90;   
           //LogRequest(DEBUG_ARTS_MODULE, cur_sess->callid,"dts-MS:%u",timestampInMS);            
            if(cur_sess->first_mpeg2_timestamp <=0)
                cur_sess->first_mpeg2_timestamp = timestampInMS;  
                        
                        //no seek get first pcr
            if(custom_struct->seek_start_dts == 0 && custom_struct->seek == false)
            {
                custom_struct->seek_start_dts = timestampInMS;
                LogRequest(DEBUG_ARTS_MODULE, cur_sess->callid,"custom_struct->seek_start_dts:%u",custom_struct->seek_start_dts);
            }  
                
        }else
            timestampInMS = 0;
                                                                                     
            // check wether seek start flag
            LogRequest(DEBUG_ARTS_MODULE, cur_sess->callid,"ptr[0]:%X,ptr[1]:%x,ptr[5]:%x",ptr[0],ptr[1],ptr[5]);
            if(ptr[0]== 0x47)
            {                      
                if( (ptr[1]&0x80) !=0)
                    error_indicator =true;
                if( (ptr[1]&0x20) != 0)
                    priority_flag =true;
                if( (ptr[1]&0x40) !=0 )
                    is_start =true;               
            }        
     
            if( error_indicator == true || priority_flag == true)
            {                       
                ptr[1]= (ptr[1] &0x5f);  
                            
                custom_struct->seek_start = true; 
                cur_sess->mpeg2_start_time = 0;
                LogRequest(DEBUG_ARTS_MODULE, cur_sess->callid,"sess->mpeg2_start_time:%"_64BITARG_"d",cur_sess->mpeg2_start_time);
                LogRequest(DEBUG_ARTS_MODULE, cur_sess->callid,"packet[1]:%X",ptr[1]);
                error_indicator = false;
                priority_flag = false;
            }      
                    
                    
                    //seek start but no receive validate TS packet
            if( (custom_struct->seek_start_dts<=0 )&& custom_struct->seek == true)
            {
                if( custom_struct->seek_start ==false  )
                {
                    
                    LogRequest(INFO_ARTS_MODULE, cur_sess->callid,"the PCR is %u,drop it", timestampInMS);
                    drop_flag = true;
                    goto  next;
                 }
                 
                  bool flag1 = isValidateSEI(ptr,TS_PACKET_SIZE);
                 
                 if ( flag1==false && (timestampInMS<=0 ) )
                 {
                   
                    LogRequest(INFO_ARTS_MODULE, cur_sess->callid,"the PCR is %u,drop it", timestampInMS);
                    drop_flag = true;
                    goto  next;
                 }
                 
                 else if(custom_struct->seek_start == true && drop_flag == true )
                 {
                    //if((ptr[5]== 0x00 || ptr[5]== 0x02 || ptr[5]== 0x42) && ((ptr[1] &0x40)!=0) && drop_flag == true)
                    //{
                        uint8_t  packet[TS_PACKET_SIZE];
                        mpegts_write_sdt(ts,cur_sess->callid,packet);
                        if(ptr-l_buf >= TS_PACKET_SIZE)
                        {
                              memcpy(ptr-TS_PACKET_SIZE,packet,TS_PACKET_SIZE);
                              lastKeyframe = ptr -TS_PACKET_SIZE;
                         }else
                         {
                              memcpy(tmp_buf,packet,TS_PACKET_SIZE);
                              ptr = tmp_buf;
                              memcpy(ptr + TS_PACKET_SIZE,l_buf,in);
                              lastKeyframe = ptr;                              
                              ptr += 2*TS_PACKET_SIZE;                              
                         }                        
                        
                        drop_flag = false;
                        
                    //}else
                    //{
                    //    if(drop_flag == true)
                    //    {
                    //        LogRequest(INFO_ARTS_MODULE, cur_sess->callid,"no sei talbe ,drop it");
                    //        drop_flag = true;
                    //        goto next;
                    //    }
                   // }
                 }
            }           
                    
            if(timestampInMS>0 && custom_struct->seek_start_dts ==0 &&custom_struct->seek== true && custom_struct->seek_start==true)
            {                  
                custom_struct->seek_start_dts = timestampInMS;
                LogRequest(INFO_ARTS_MODULE, cur_sess->callid,"Get the new start,PCR:%u",timestampInMS);  
                custom_struct->seek_start = false;
                 
                if(custom_struct != NULL && strlen(custom_struct->rangeHeader_global)>0)
                {   
                    cur_sess->head.state &= ~ARTS_CALL_STATE_PLAY_CMD_SENT; 
                    LogRequest(INFO_ARTS_MODULE, cur_sess->callid,"will send Play");    
                    send_play_request(callid);  
                }     
                    
            }   
                
            if(custom_struct->pause == true)
            {
                custom_struct->pause_start_time = getcurTs(timestampInMS,custom_struct); 
                LogRequest(INFO_ARTS_MODULE, cur_sess->callid, "pause_start_time:%u",custom_struct->pause_start_time);
                custom_struct->pause = false;
            }
             
                
            if(PCR != -1 && custom_struct->first_pts >=0)
            {                          
                  if( !(custom_struct->seek == true && custom_struct->seek_start_dts<=0)){                            
                          LogRequest(DEBUG_ARTS_MODULE, cur_sess->callid,"drop other packets"); 
                          ptr = l_buf + in;               
                          break;
                   }                  
            }    
                    
            if(PTS>-1)
            {      
                
               if(custom_struct->first_keyframe_pts <0)
               {
                    custom_struct->first_keyframe_pts = PTS;
                    LogRequest(DEBUG_ARTS_MODULE, cur_sess->callid,"custom_struct->first_keyfame_pts:%d",PTS);
               }      
                      
                                 
                if(custom_struct->first_pts <0)
                {
                    custom_struct->first_pts = PTS;
                    LogRequest(DEBUG_ARTS_MODULE, cur_sess->callid,"custom_struct->first_pts:%d",PTS);
                    
                }else   if(seek_flag == true)
                {
                    custom_struct->last_keyframe_pts = PTS;
                    LogRequest(DEBUG_ARTS_MODULE, cur_sess->callid,"seek start PTS:%u",PTS/90);
                    seek_flag = false;
                }
                     /*
                offset = ptr - lastKeyframe;
                if(offset > 0)
                {
                    rtp_packet_buffer_type *pkt_buf = newRtpBuf(ptr,offset,stream_type);
                    pkt_buf->pts = lastPTS;
                    pkt_buf->timestamp = getcurTs(timestampInMS,custom_struct);                                                        
                    insertPktInBuf(cur_sess,pkt_buf);
                }     
                                                                 
                lastPTS = PTS;
                lastKeyframe = ptr;
                PCR = -1;
                */
                
               //if(custom_struct->last_keyframe_pts == -1)
                   
                
                
                custom_struct->pause = false;
            }
                                          
next:                   
            ptr += TS_PACKET_SIZE;
            pktLen -= TS_PACKET_SIZE;
                 
        }
                
                
                // offset ==0 --> nokeyframe in whole buf                       
        if(drop_flag == false &&(offset == 0  || ptr-lastKeyframe >0 )) 
        {
            offset = ptr-lastKeyframe;
            rtp_packet_buffer_type *pkt_buf = newRtpBuf(lastKeyframe,offset,stream_type);
            pkt_buf->pts = lastPTS;
            pkt_buf->timestamp = getcurTs(timestampInMS,custom_struct);  
            //pkt_buf->timestamp =  timestampInMS;
            insertPktInBuf(cur_sess,pkt_buf);
        }  
        
        
}
    
static int handle_TS_Pkt_NoIpqam(arts_session *cur_sess,int callid ,custom_struct_t * custom_struct,rtp_packet_buffer_type * rtp_packet_buffer)
{
    if(custom_struct == NULL || rtp_packet_buffer == NULL)
        return 0;
        
    int valid_pkt = true;
    QTSS_PacketStruct thePacket;
    QTSS_TimeVal timestampInMS;
    SInt64 PCR = -1,tmpPCR =-1;
    thePacket.packetData = rtp_packet_buffer->pkt_buf;
    UInt32 pktLen = rtp_packet_buffer->pkt_len;
    UInt8* ptr = (UInt8*)thePacket.packetData;
    bool error_indicator =false;
    bool priority_flag =false;
    bool is_start=false;
    bool new_start=false;
    
    
    Assert(cur_sess!=NULL);    
            
    while(pktLen >= TS_PACKET_SIZE)
    {                       
        //LogRequest(DEBUG_ARTS_MODULE, sess->callid," first:%X,orig:%X",ptr[0],ptr[1]);                    
        tmpPCR = GetMPEG2PCR(ptr, &pktLen); 
        if(tmpPCR>-1)
        {
            LogRequest(DEBUG_ARTS_MODULE, callid,"PCR-MS:%u",tmpPCR/27/1000);
        }
        
        if(tmpPCR >-1 && PCR ==-1)
        {
            PCR = tmpPCR;
        }
                    
        LogRequest(DEBUG_ARTS_MODULE, callid,"ptr[0]:%X,ptr[1]:%x",ptr[0],ptr[1]);
        if(ptr[0]== 0x47)
        {                      
            if( (ptr[1]&0x80) !=0)
                error_indicator =true;
            if( (ptr[1]&0x20) != 0)
                priority_flag =true;
            if( (ptr[1]&0x40) !=0 )
                is_start =true;               
        }        
     
        if( error_indicator == true || priority_flag == true)
        {                       
            ptr[1]= (ptr[1] &0x5f);
            if(tmpPCR == -1)
                PCR = -1;
                            
            custom_struct->seek_start = true; 
            cur_sess->mpeg2_start_time = 0;
            LogRequest(DEBUG_ARTS_MODULE, callid,"sess->mpeg2_start_time:%"_64BITARG_"d",cur_sess->mpeg2_start_time);
            LogRequest(DEBUG_ARTS_MODULE, callid,"packet[1]:%X",ptr[1]);
            error_indicator = false;
            priority_flag = false;
        }                       
                    
                    
                    
        if(PCR != -1)
        {                          
            if( !(custom_struct->seek == true && custom_struct->seek_start_dts<=0)){                            
                LogRequest(DEBUG_ARTS_MODULE, callid,"drop other packets");                
                break;
            }                  
        }
        ptr += TS_PACKET_SIZE;
        pktLen -= TS_PACKET_SIZE;
                 
    }
    
    if(PCR != -1)
    {
        timestampInMS = PCR / 27 / 1000 ;                    
        if(cur_sess->first_mpeg2_timestamp <=0)
            cur_sess->first_mpeg2_timestamp = timestampInMS;  
                        
        if(custom_struct->seek_start_dts == 0 && custom_struct->seek == false)
        {
            custom_struct->seek_start_dts = timestampInMS;
            LogRequest(DEBUG_ARTS_MODULE, callid,"custom_struct->seek_start_dts:%u",custom_struct->seek_start_dts);
        }  
                
    }else
        timestampInMS = 0;           
                     

    if( (custom_struct->seek_start_dts<=0 )&& custom_struct->seek == true)
    {
        if( custom_struct->seek_start ==false)
        {
            LogRequest(DEBUG_ARTS_MODULE, callid,"the PCR is %u,drop it", timestampInMS);
            free(rtp_packet_buffer->pkt_buf);
            free(rtp_packet_buffer);
            valid_pkt = false;
            return valid_pkt;
        }
    }
 
               
    if(timestampInMS>0 && custom_struct->seek_start_dts ==0 &&custom_struct->seek== true && custom_struct->seek_start==true)
    {                  
        custom_struct->seek_start_dts = timestampInMS;
        LogRequest(DEBUG_ARTS_MODULE, callid,"Get the new start,PCR:%u",timestampInMS);  
        custom_struct->seek_start = false;
        if(custom_struct != NULL && strlen(custom_struct->rangeHeader_global)>0)
        {   
            cur_sess->head.state &= ~ARTS_CALL_STATE_PLAY_CMD_SENT; 
            LogRequest(DEBUG_ARTS_MODULE,callid,"will send Play");    
            send_play_request(callid);  
        }     
                    
    }           
                              
               
    if( timestampInMS >0)
        custom_struct ->last_recv_PCR = timestampInMS;                
                
    int64_t lasttimestampInMS = custom_struct ->last_recv_PCR;                      
    rtp_packet_buffer ->timestamp = ARTSMAX(timestampInMS,lasttimestampInMS); 
                
            
   
    QTSS_TimeVal CurrentTime = QTSS_Milliseconds();                      
    LogRequest(DEBUG_ARTS_MODULE, callid, "current_time:%"_64BITARG_"d,type = %c,buffer_len  = %d ,"
        "PCR: %"_64BITARG_"d,pkt_len:%d" ,CurrentTime,TYPE_TO_C(rtp_packet_buffer->pkt_str),
        cur_sess->rtp_packet_buffer_len,rtp_packet_buffer ->timestamp,rtp_packet_buffer->pkt_len);  
        
    return valid_pkt;
}




SInt64 ARTS_Get_Packet::Run()
{
    LogRequest(DEBUG_ARTS_MODULE,this->callid," ARTS_Get_Packet,cuttime: %"_64BITARG_"d",QTSS_Milliseconds());  
    if(this->buffer_len <=0)
    {
        return 0;
    }  
    
    int ret =1;
    
    custom_struct_t *custom_struct = NULL;
    arts_session *cur_sess = NULL;
    
    cur_sess = (arts_session *)this->sess;
         
    if(cur_sess == NULL)
          return  -1;
    Assert(cur_sess != NULL);
    custom_struct= (custom_struct_t *)cur_sess->darwin_custom_struct;
    rtp_packet_buffer_type * rtp_packet_buffer = NULL;
     
    
    if(custom_struct->isIpqam == false && custom_struct->supportPTS==false )
    {
        rtp_packet_buffer = newRtpBuf(this->buffer,this->buffer_len, this->stream_type);
    }
    
    
    if(this->buffer_len>0 && custom_struct->ifd!= NULL)
    {        
        fwrite(this->buffer,sizeof(char),this->buffer_len,custom_struct->ifd);                 
    }
    LogRequest(DEBUG_ARTS_MODULE,this->callid,"cur_sess->transport_type:%d",cur_sess->transport_type);
    if(cur_sess->transport_type != qtssRTPTransportTypeMPEG2)
    {
        
        ret = handle_RTP_Pkt(cur_sess,this->callid,custom_struct,rtp_packet_buffer);
    }else
    {
        if(custom_struct->isIpqam == false)
        {
            if(custom_struct->supportPTS==true)
            {
                ret = handle_TS_Pkt_PTS(cur_sess,this->callid,this->buffer,this->buffer_len);
            }else
                ret = handle_TS_Pkt_NoIpqam(cur_sess,this->callid,custom_struct,rtp_packet_buffer);
        }else
        {           
            ret =handle_TS_Pkt_Ipqam(cur_sess,this->callid,custom_struct,this->buffer,this->buffer_len);
        }
    }
    
    
    if(cur_sess->aud_discont == 1 && cur_sess->vid_discont == 1 && cur_sess->flush_discont == 1)
    {
        clear_buffer(cur_sess);              
        LogRequest(DEBUG_ARTS_MODULE, cur_sess->callid,"clear buffer list due to sess->discont");
    }           
                          
       //ret is true is validate pkts when seek
    if(rtp_packet_buffer != NULL && custom_struct->isIpqam == false && ret== 1 && custom_struct->supportPTS==false)
    {    
        insertPktInBuf(cur_sess,rtp_packet_buffer);
    }
    
    return 0;    
}


bool ARTS_PH_Interface::Configure(char *pBackends,char * pBindHost, UInt16 lport)
{
    char *colon;
    char *hostname = NULL, *port = NULL;
    int portnum = 0;

    // Get the listenport and start listening to it
    if (lport)
    {
        listenport = lport;
        listensock->fd = arts_adapter_listen( pBindHost ,listenport);
        if(-1 == listensock->fd)
        {
            LogRequest(INFO_ARTS_MODULE, 0, "arts_adapter_listen error");
            return false;
        }
    }
    else
    {
        LogRequest(INFO_ARTS_MODULE, 0, "no listenport specified");
        return false;
    }

    // Get the controller configuration
    if (NULL != (colon = strrchr(pBackends, ':')))
    {
    int len = colon - pBackends;
    hostname = new char[len+1];
    strncpy(hostname, pBackends, len );
    hostname[len] = 0;
    port = new char[strlen(colon + 1) + 1];
    strcpy(port, colon + 1);

    portnum = atoi(port);
    LogRequest(INFO_ARTS_MODULE, 0, "controller address: IP = %s, port = %d", hostname, portnum);

    bzero( (void *)&servaddr, sizeof(servaddr) );
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(portnum);
    servaddr.sin_addr.s_addr = inet_addr(hostname);

    free(hostname);
    free(port);
    }
    else
    {
        LogRequest(INFO_ARTS_MODULE, 0, "bad controller address specified %s",  pBackends);
        return false;
    }

    return true;
}


void del_event_ptr(event_node_t * prev,event_node_t * p)
{
    if (prev == NULL || p== NULL)
        return;
     if(  p == prev )
    {
        sARTSPHInterface->stop_events = (event_node_t*)p->next;
        prev->next = NULL;
        free(prev);
        LogRequest(INFO_ARTS_MODULE, 0,"get event node ,will free it,fd:%d",p->fd);
    }else
    {
        prev->next = p->next;
        p->next= NULL;
        free(p);
        LogRequest(INFO_ARTS_MODULE, 0,"get event node ,will free it,fd:%d",p->fd);
    }
}



void ARTS_PH_Interface::Entry()
{
    fdevent_revents *revents = fdevent_revents_init();
    int poll_errno;
    int n;

    QTSS_TimeVal prevTs = QTSS_Milliseconds(), curTs;
    //LogRequest(INFO_ARTS_MODULE, 0,"Entry,revents:%x",revents);
    while(IsStopRequested() == false)
    {
        // Do the poll
       // LogRequest(INFO_ARTS_MODULE, 0,"start poll,time:%"_64BITARG_"d",QTSS_Milliseconds());        
        n = fdevent_poll(ev, this->polltimeout);        
        //LogRequest(INFO_ARTS_MODULE, 0,"poll finish");
        poll_errno = errno;
        
        if (n > 0) 
        {
           // LogRequest(INFO_ARTS_MODULE, 0,"event occur,time:%"_64BITARG_"d",QTSS_Milliseconds());
            /* n is the number of events */
            size_t i;
            fdevent_get_revents(ev, n, revents);
            //LogRequest(INFO_ARTS_MODULE, 0,"finish get event");
            for (i = 0; i < revents->used; i++) 
            {
               fdevent_revent *revent = revents->ptr[i];
               handler_t r;
      
               switch (r = (*(revent->handler))(this, revent->context, revent->revents)) 
               {
                case HANDLER_FINISHED:
                case HANDLER_GO_ON:
                case HANDLER_WAIT_FOR_EVENT:
                    break;
                case HANDLER_ERROR:
                    /* should never happen */
                    Assert(false);
                    break;
                default:
                    LogRequest(INFO_ARTS_MODULE, 0, "event loop returned: %d", (int) r);
                    break;
               }
           }
        } 
        else if (n < 0 && poll_errno != EINTR) 
        {
                 LogRequest(INFO_ARTS_MODULE, 0, "event loop: fdevent_poll failed: %s", strerror(poll_errno)); 
        }
        
        event_node_t *p = this->stop_events;
        event_node_t * prev =p;
       
        while(p)
        {         
              
             //arts_session * sess=  arts_session_find(p->callid); 
             
             arts_session * sess = (arts_session *)p->sess;
             
             if(sess->callid != p->callid )
             {     
                        
                //LogRequest(INFO_ARTS_MODULE, p->callid, "sess->callid :%d,p->callid:%d,p->fd:%d",sess->callid,p->callid,p->fd );               
                event_node_t *nextp = (event_node_t *) p->next;
                del_event_ptr(prev,p);
                p= nextp;
                continue;
              }
             
            if ( p->unregister ==1 && sess!= NULL && sess->darwin_custom_struct != NULL)
            {             
               // OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
                
                custom_struct_t * custom_struct = (custom_struct_t *)sess->darwin_custom_struct;   
               // LogRequest(INFO_ARTS_MODULE, sess->callid,"sess->head.sock->fd:%d,custom_struct:%x",sess->head.sock->fd,custom_struct);              
                if( custom_struct->buf_duration < 3000 && custom_struct->buf_duration >=0 && custom_struct->adapter_unregister == true)
				{			 
                  fdevent_event_add(this->ev, sess->head.sock, FDEVENT_IN | FDEVENT_HUP );	
                  //LogRequest(INFO_ARTS_MODULE, sess->callid,"event_add,fd:%d",sess->head.sock->fd);
                  p->unregister = 0;
                  custom_struct->adapter_unregister = false;                		
				}            
            }  
            
            p = (event_node_t *) p->next;      
        }

        // Call Trigger once per second only
        curTs = QTSS_Milliseconds();
        if(curTs >= prevTs + this->polltimeout) 
        {
            Trigger();
            prevTs = curTs;
        }
        
        
    }
    fdevent_revents_free(revents);
}

void ARTS_PH_Interface::Trigger()
{
	char  l_buf[128];  //must be big enough to hold ipv6 address
	char  l_portBuf[8];
	
	
	//LogRequest(INFO_ARTS_MODULE, 0,"Entry Triugger:%"_64BITARG_"d",QTSS_Milliseconds());
    //LogRequest(INFO_ARTS_MODULE, 0,"Trigger Entry,control_state:%d",control_state);
    /* the trigger handle cares about the SCTP connection with the controller */
    switch(control_state)
    {
    case ARTS_CONTROLLER_STATE_UNSET:
    /* This is the first time in after init so add the listen socket as well*/
    fdevent_register(ev, listensock, arts_handle_listener_fdevent, NULL);
    fdevent_event_add(ev, listensock, FDEVENT_IN);

    /* Fall Through */
    case ARTS_CONTROLLER_STATE_IDLE:
    /* The controller is down so try connecting with the controller*/
        if(controllertimeout != 0)
        {
             controllertimeout --;
             break;
        }

        switch(arts_controller_connect(&servaddr, &controlsock->fd))
        {
        case HANDLER_WAIT_FOR_FD:
            break;

        case HANDLER_WAIT_FOR_EVENT:
     
            LogRequest(INFO_ARTS_MODULE, 0, "controller connection establishing");
     
            fdevent_register(ev, controlsock, arts_handle_controller_fdevent, NULL);
            fdevent_event_add(ev, controlsock, FDEVENT_OUT | FDEVENT_HUP);
            control_state = ARTS_CONTROLLER_STATE_CONNECTING;
            break;
     
        case HANDLER_GO_ON:
            
            LogRequest(INFO_ARTS_MODULE, 0, "controller connection established");
     
			sprintf(l_portBuf,":%d",listenport);
            arts_send_registration(controlsock->fd, sARTSSystemName, ARTS_PH_TYPE_RTSP, strcat(strcpy(l_buf,sARTSBindHost),l_portBuf) );
            fdevent_register(ev, controlsock, arts_handle_controller_fdevent, NULL);
            fdevent_event_add(ev, controlsock, FDEVENT_IN | FDEVENT_HUP);
            control_state = ARTS_CONTROLLER_STATE_READ_REG_RESPONSE;
            break;
     
        default:
            LogRequest(INFO_ARTS_MODULE, 0, "controller connection error ");
            break;
        }
       break;

    default:
           break;
    }
}

// Handle Controller events
handler_t arts_handle_controller_fdevent(void *s, void *ctx, int revents) 
{
    ARTS_PH_Interface *srv = (ARTS_PH_Interface *) s;
	char l_buf[128];
	char l_portBuf[8];
    int flags = 0;
    
	LogRequest(INFO_ARTS_MODULE, 0, "controller connection event=%d: %d", revents, srv->control_state);

    if(revents & FDEVENT_IN)
    {
        //Read event
        OSMutexLocker l_autoMutex(&srv->sessionMutex);
        flags = arts_handle_controller_resp(srv->controlsock->fd, srv);
    }

    if ((flags == 0) && (revents & FDEVENT_OUT))
    {
        // Outbound connection succeeded
        //arts_send_registration(srv->controlsock->fd, sARTSSystemName, ARTS_PH_TYPE_RTSP, srv->listenport);inet_ntoa()
		sprintf(l_portBuf ,":%d",srv->listenport);
		arts_send_registration(srv->controlsock->fd, sARTSSystemName, ARTS_PH_TYPE_RTSP, strcat(strcpy(l_buf,sARTSBindHost),l_portBuf));
        srv->control_state = ARTS_CONTROLLER_STATE_READ_REG_RESPONSE;

        LogRequest(INFO_ARTS_MODULE, 0, "controller connection established");

        fdevent_event_add(srv->ev, srv->controlsock, FDEVENT_IN | FDEVENT_HUP);
    }

    if((flags == -1) ||(revents & FDEVENT_HUP) || (revents & FDEVENT_ERR))
    {        // Controller Socket is down
        srv->controllertimeout = 10;
        srv->control_state = ARTS_CONTROLLER_STATE_IDLE;

        LogRequest(INFO_ARTS_MODULE, 0, "controller connection down");

        fdevent_event_del(srv->ev, srv->controlsock);        
        close(srv->controlsock->fd);
        // Also need to put code to cleanup session structs
    }
  
    return HANDLER_GO_ON;
}


void del_adapter_fdevent(arts_session * sess,int fd)
{
   /// OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
    if(sess!=NULL)
    {
        custom_struct_t * custom_struct =(custom_struct_t *)  sess->darwin_custom_struct;
        custom_struct->adapter_unregister = true; 
        LogRequest(INFO_ARTS_MODULE, sess->callid, "unregister adapter ");
        stop_getpkts_thread(sess);
    }     
    
    del_events_node(fd);
    LogRequest(INFO_ARTS_MODULE, 0,"free event_node,fd:%d",fd);  
}


// Handle SCTP Connections from the adapter
handler_t arts_handle_adapter_fdevent(void *s, void *ctx, int revents) 
{

    LogRequest(DEBUG_ARTS_MODULE, 0, "arts_handle_adapter_fdevent: entering");

    ARTS_PH_Interface *srv = (ARTS_PH_Interface *) s;
    
    OSMutexLocker l_autoMutex(&srv->sessionMutex);

    int in = 0;
    arts_session_head *sess_head = (arts_session_head *) ctx;
    arts_session *sess = NULL;
    
    int release_flag =0;
    
    if(sess_head->state != ARTS_CALL_STATE_UNSET)
    {
        // This is a real session and not a session head, 
        sess = (arts_session *) ctx;
    }      

    //OSMutexLocker l_autoMutex(&srv->sessionMutex);
    if(revents & FDEVENT_IN)
    {
        int flags = 0;
        //int flags = MSG_CONFIRM;
        struct sctp_sndrcvinfo sndrcvinfo;
        
        
          if(sess!=NULL && (sess->head.state & ARTS_CALL_STATE_DESTROY_NOW) )
          {
            fdevent_event_del(srv->ev, sess_head->sock);        
            fdevent_unregister(srv->ev, sess_head->sock);
            
            if(sess->head.sock!=NULL)
            {            
                del_events_node(sess->head.sock->fd);
                LogRequest(INFO_ARTS_MODULE, sess->callid,"free event_node,sess->head->fd:%d",sess->head.sock->fd);
            }
            free_custom_struct(sess,NULL);
            LogRequest(INFO_ARTS_MODULE, sess->callid,"free sess,sess->fd:%d",sess->head.sock->fd);
            arts_session_free(sess,1);   
            srv->polltimeout = 1000;  
            return HANDLER_GO_ON;
          }
                    
       
        //in = sctp_recvmsg( sess_head->sock->fd, (void *)srv->tmpbuffer, sizeof(srv->tmpbuffer),
        //                (struct sockaddr *)NULL, 0, &sndrcvinfo, &flags );
        
        int len = 3948;
        char tmpbuffer[3948];
        
        if(sess!= NULL && sess->transport_type==qtssRTPTransportTypeMPEG2)
        {
            len =1316;
        }
        
        
        in = sctp_recvmsg( sess_head->sock->fd, (void *)tmpbuffer, len,
                (struct sockaddr *)NULL, 0, &sndrcvinfo, &flags );
                
        LogRequest(DEBUG_ARTS_MODULE, 0, "arts_handle_adapter_fdevent: data received: data_len = %d",in);

        // If in < 1 then Connection went down
        if( (in > 0) && (!sess) )
        {
            // First Data received on socket. We need to associate with a real session struct
            // Remove the fd from the event loop.
            fdevent_event_del(srv->ev, sess_head->sock);        
            fdevent_unregister(srv->ev, sess_head->sock);
            sess = arts_session_find(sndrcvinfo.sinfo_ppid);

            if(!sess || (sess->head.state & ARTS_CALL_STATE_DESTROY_NOW))
            {
                // Session not found. Cleanup and return.
                LogRequest(INFO_ARTS_MODULE, sndrcvinfo.sinfo_ppid, "adapter unexpected connection");                                            
                arts_session_head_free(sess_head);
                return HANDLER_GO_ON;
            }
            else
            {
               LogRequest(DEBUG_ARTS_MODULE, 0, "sess_head->sock:%x,sess->head.sock:%x,sARTSIpqamHost:%s,sARTSIpqamPort:%d",sess_head->sock,sess->head.sock,sARTSIpqamHost,sARTSIpqamPort);
                // Session found.
                sess->head.state |= ARTS_CALL_STATE_CONNECTED;             
                
                sess->head.sock = sess_head->sock;
                LogRequest(DEBUG_ARTS_MODULE, 0,"sess->head.sock:%x",sess->head.sock);
                sess_head->sock = NULL;
                 
                arts_session_head_free(sess_head);                
                        
                fdevent_register(srv->ev, sess->head.sock, arts_handle_adapter_fdevent, sess);   
                if(sess->head.state & ARTS_CALL_STATE_PLAY)
				{	//we must wait until we received response from Adapter and then we can move on to process data from adapter
					// before that we only listen to HUP,ERR events, data will be hold. 
                  fdevent_event_add(srv->ev, sess->head.sock, FDEVENT_IN | FDEVENT_HUP );
					
				}                 
                           
                 if (sess->darwin_custom_struct ==NULL)
                 {              
                        custom_struct_t * custom_struct = (custom_struct_t *)malloc(sizeof(custom_struct_t));
                        memset(custom_struct ,0,sizeof(custom_struct_t));
                        
                        if(dump_input == true)
                        {
                            custom_struct->ifd = arts_open_file();
                            LogRequest(DEBUG_ARTS_MODULE, sess->callid,"dump input readyed");
                        }
                        
                        if(dump_output == true)
                        {
                            custom_struct->ofd = arts_open_file();
                            LogRequest(DEBUG_ARTS_MODULE, sess->callid,"dump output readyed");
                        }
                        
                        custom_struct->supportPTS = sARTSSupportPTS;
                        custom_struct->first_pts =-1;
                        custom_struct->last_keyframe_pts =-1;
                        custom_struct->first_keyframe_pts =-1;
                        custom_struct->buf_duration = -1;
                        custom_struct->play_idel = 0;
                        
                        MpegTSContext * tsctx = (MpegTSContext*) malloc(sizeof( MpegTSContext));
                        Assert(tsctx!=NULL);
                        memset(tsctx ,0,sizeof(MpegTSContext));
                        init_tscontext(tsctx,MUX_RATE,sARTSIpqamPCRInterval);
                        
                        custom_struct->tsctx = tsctx; 
                        LogRequest(DEBUG_ARTS_MODULE, sess->callid,"cur_pcr:%d,last_pcr:%d,mux-rate:%d,delay:%d",tsctx->cur_pcrMS,tsctx->last_pcr,tsctx->mux_rate,tsctx->pcr_retransmit_time);
                       
                       
                        if(sARTSIpqamHost!= NULL && strlen(sARTSIpqamHost)>0 &&sARTSIpqamPort >0)
                        {
                             custom_struct->isIpqam = true;
                             LogRequest(DEBUG_ARTS_MODULE, sess->callid,"Entry Ipqam mode");
                             
                        }
                                 
                        sess->darwin_custom_struct =custom_struct;
                        inputfile = NULL;
                        if(sARTSInputFile != NULL)
                            inputfile = fopen(sARTSInputFile,"rb");
                        if(inputfile!=NULL)
                        {
                            LogRequest(DEBUG_ARTS_MODULE, sess->callid, " %s open success!",sARTSInputFile);   
                        }
                       /*
                        if(custom_struct->ifd != NULL && in>0)
                        {
                            fwrite(srv->tmpbuffer,sizeof(char),in,custom_struct->ifd);               
                        }   */
                        custom_struct->adapter_unregister = true;
                        insert_stopEventsList(sess->callid,FDEVENT_IN | FDEVENT_HUP,sess,sess->head.sock->fd);   
                        LogRequest(INFO_ARTS_MODULE, sess->callid,"unregister adapter util receive play request");  
                        srv->polltimeout =100;
                   
                    }  
                    
               }    
        }
             
        if(in >0)
        {   
             srv->polltimeout =100;
             custom_struct_t * custom_struct =(custom_struct_t *)  sess->darwin_custom_struct;
             
             if(sess == NULL || sess->darwin_custom_struct == NULL)
             {
                LogRequest(INFO_ARTS_MODULE, sess->callid,"receive_pkts stop,we will unregist adapter");
                fdevent_event_del(srv->ev, sess_head->sock);        
                fdevent_unregister(srv->ev, sess_head->sock); 
            
                return HANDLER_GO_ON;
             }
             
            if(sess->head.state & ARTS_CALL_STATE_PLAY)
            {                                          
                   
                   ARTS_Get_Packet * sARTSGetPacket =(ARTS_Get_Packet *) custom_struct->receive_pkts_thread;
                   
                   if(sARTSGetPacket != NULL&& in >0)
                   {                                
                   
                    if(inputfile != NULL)
                    {
                        while(true)
                        {
                            int64_t total_len = 0;
                            int64_t real_size=fread(sARTSGetPacket->buffer,sizeof(char),1316,inputfile);
                            sARTSGetPacket->buffer_len = real_size;
                            total_len += real_size;
                            if(real_size <=0)
                            {
                                custom_struct_t * custom_struct =(custom_struct_t *)  sess->darwin_custom_struct;
                                custom_struct->adapter_unregister = true; 
                                LogRequest(INFO_ARTS_MODULE, sess->callid, "unregister adapter ");
                                stop_getpkts_thread(sess);
               
            
                                srv->polltimeout=1000;
                                del_events_node(sess->head.sock->fd);
                                LogRequest(INFO_ARTS_MODULE, sess->callid,"free event_node"); 
                            
                                return HANDLER_GO_ON;                          
                            }
                            sARTSGetPacket->Run();
                            
                            if(total_len >= in*10)
                            {
                                break;
                            }
                            if( (custom_struct->buf_duration >= 3000 ) )
                            {
                                fdevent_event_del(srv->ev, sess->head.sock);                                                                            
                                set_unregister(sess);       
                                custom_struct->adapter_unregister = true;
                                //LogRequest(INFO_ARTS_MODULE, sess->callid,"buffer is full,unregister adapter,fd:%d",sess->head.sock->fd);
                                return HANDLER_GO_ON; 
                            }       
                        
                        }                     
                        
                    }else
                    {
                     memcpy(sARTSGetPacket->buffer,tmpbuffer,in);
                     sARTSGetPacket->buffer_len = in;
                     sARTSGetPacket->stream_type = sndrcvinfo.sinfo_stream;
                     sARTSGetPacket->sess = sess;
                     sARTSGetPacket->Run();                   
                     }
                      
                    }
                    
                    
                    if( (custom_struct->buf_duration >= 3000 ) )
                    {
                        fdevent_event_del(srv->ev, sess->head.sock);
                                                                     
                        set_unregister(sess);       
                        custom_struct->adapter_unregister = true;
                       // LogRequest(INFO_ARTS_MODULE, sess->callid,"buffer is full,unregister adapter,fd:%d",sess->head.sock->fd);
                    }              
            }
            
            else
            {
                    /*
                   //HTTP Initial Response not yet send. Save the packet for later play
                   sess->data_bytes_sent += in;                       
                   ARTS_Get_Packet * sARTSGetPacket =(ARTS_Get_Packet *) custom_struct->receive_pkts_thread;                   
                   if(sARTSGetPacket != NULL&& in >0)
                   {   
                     memcpy(sARTSGetPacket->buffer,tmpbuffer,in);
                     sARTSGetPacket->buffer_len = in;
                     sARTSGetPacket->stream_type = sndrcvinfo.sinfo_stream;
                     sARTSGetPacket->sess = sess;
                     sARTSGetPacket->Run(); 
                   }
                    */
                    
                    if(custom_struct->isIpqam==0)
                    {
                        memcpy(sess->first_packet.pkt_buf, tmpbuffer, in );
                        sess->first_packet.pkt_str = sndrcvinfo.sinfo_stream;
                        sess->first_packet.pkt_len = in ;
                    }
            }                
                
            if( ( !(sess->head.state & ARTS_CALL_STATE_PLAY))  && 
                    (sess->head.state & ARTS_CALL_STATE_READ_CON_RESPONSE) )
            {
                Task *l_Task = (Task *)sess->task_ptr;
                        if(l_Task)
                        {
                            LogRequest(INFO_ARTS_MODULE, sess->callid, "Signal data Received Event");
           
                            ARTS_SignalStream(l_Task,Task::kReadEvent);
                        }
                        else
                            Assert(false);
             }
                
            LogRequest(DEBUG_ARTS_MODULE, sess->callid, "adapter call connected ");
        }
            
        if(in==0 && sess&& sess->head.sock!=NULL)
        {        
           del_adapter_fdevent(sess,sess->head.sock->fd);
           sess->event_release = 1;
           srv->polltimeout=1000; 
           release_flag =1;        
        }       
        
    }
    if((in <=0) || (revents & FDEVENT_HUP) || (revents & FDEVENT_ERR))
    {
        // Connection went down
        if(release_flag ==0)
        {
            del_adapter_fdevent(sess,sess_head->sock->fd);
        }  
       
        fdevent_event_del(srv->ev, sess_head->sock);        
        fdevent_unregister(srv->ev, sess_head->sock);
        LogRequest(INFO_ARTS_MODULE, 0, "arts_handle_adapter_fdevent: No data or Socket closed for fd = %d", sess_head->sock->fd);
        srv->polltimeout=1000; 
        //arts_session_head_free(sess_head);
        return HANDLER_GO_ON;
    }
    return HANDLER_GO_ON;  
   //return HANDLER_COMEBACK;     
}

handler_t arts_handle_listener_fdevent(void *s, void *ctx, int revents) 
{
    ARTS_PH_Interface *srv = (ARTS_PH_Interface *) s;
    
    LogRequest(INFO_ARTS_MODULE, 0, "arts_handle_listener_fdevent: listener connection event = %d", revents);

    if(revents & FDEVENT_IN)
    {
        int newfd = arts_adapter_accept(srv->listensock->fd, srv->control_state);
        if(newfd != -1)
        {
            arts_session_head *sess_head = arts_session_head_init();
            sess_head->sock->fd = newfd;
            fdevent_register(srv->ev, sess_head->sock, arts_handle_adapter_fdevent, sess_head);
            fdevent_event_add(srv->ev, sess_head->sock, FDEVENT_IN | FDEVENT_HUP);
                        
            LogRequest(INFO_ARTS_MODULE, 0, "arts_handle_listener_fdevent: listener new connection fd = %d", sess_head->sock->fd);
        }
    }
    return HANDLER_GO_ON;
}

// Handle Registration response
static void arts_rtsp_reg_handler(void *ctx, unsigned char regid)
{
    ARTS_PH_Interface *srv = (ARTS_PH_Interface *) ctx;
    if(srv->control_state == ARTS_CONTROLLER_STATE_READ_REG_RESPONSE)
    {
        srv->control_state = ARTS_CONTROLLER_STATE_ACTIVE;
        srv->phid = regid;

        LogRequest(INFO_ARTS_MODULE, 0, "registration received id=%d", regid);
		qtss_printf("ARTS RTSP Module: registration received id=%d\n", regid);
    }
}

// Handle Connection Response
static void arts_rtsp_conresp_handler(void *ctx, arts_session *p_sess, int count, arts_ph_keyValue *p_keyValuePairs)
{
    LogRequest(INFO_ARTS_MODULE, p_sess->callid, "connection response received ");

    p_sess->keyValuePairs = arts_ph_create_keyvalues(count);
    p_sess->numKeyValuePairs = count;
    for(int i=0; i < count; i++)
    {
        arts_ph_calloc_keyvalue(p_sess->keyValuePairs, i ,  p_keyValuePairs[i].name, p_keyValuePairs[i].value);
    }
    Task *l_Task = (Task *)p_sess->task_ptr;

    if(l_Task)
        ARTS_SignalStream(l_Task,Task::kReadEvent);
    else
        Assert(false);
}

// Handle Connection Release
static void arts_rtsp_conrel_handler(void *ctx, arts_session *p_sess, unsigned int cause)
{
    //ARTS_PH_Interface *srv = (ARTS_PH_Interface *) ctx;
    LogRequest(INFO_ARTS_MODULE, p_sess->callid, "connection release received");

    if(cause)
    {
    // This is an abort. Be careful, the enum for cause may change with change in xml file
    // Remove the fd from the event loop
        LogRequest(INFO_ARTS_MODULE, p_sess->callid, "Cause = %d", cause);
        QTSS_ClientSessionObject theClientSession = p_sess->remote_con;
        p_sess->head.state = ARTS_CALL_STATE_DESTROY_NOW;
        qtss_printf("p_sess->head.state = ARTS_CALL_STATE_DESTROY_NOW;\n");
        p_sess->ReleaseCause = cause;
        
                
        if(theClientSession)
	    {
			if(  (  (!(p_sess->head.state & ARTS_CALL_STATE_CONNECTED))  &&
				    (!(p_sess->head.state & ARTS_CALL_STATE_READ_CON_RESPONSE)) ) || //Ex Adapter Resource not Available
				    ( !(p_sess->head.state & ARTS_CALL_STATE_PLAY)) )                //Ex URI Not found
			{
				Task *l_Task = (Task *)p_sess->task_ptr;
				if(l_Task)
				{
					LogRequest(INFO_ARTS_MODULE, p_sess->callid, "Signal Stream");
				
					ARTS_SignalStream(l_Task,Task::kReadEvent);
				}
				else
					Assert(false);
			}
			else
			{   
			    LogRequest(DEBUG_ARTS_MODULE, p_sess->callid,"QTSS_Teardown");
				(void)QTSS_Teardown(theClientSession);
            }
	    }
    }
    else if(!(p_sess->head.state & ARTS_CALL_STATE_CONNECTED))
    {
        LogRequest(INFO_ARTS_MODULE, p_sess->callid, "Call State = %d", p_sess->head.state);
    
        // We are not connected, then just delete the session and send Teardown
        p_sess->head.state = ARTS_CALL_STATE_DESTROY_NOW;
        qtss_printf("p_sess->head.state = ARTS_CALL_STATE_DESTROY_NOW;123\n");
        p_sess->ReleaseCause = proto64::Normal;
        QTSS_ClientSessionObject theClientSession = p_sess->remote_con;
        if(theClientSession){
            (void)QTSS_Teardown(theClientSession);
        }
    }
    else
    {
        // This is a normal close
       
        p_sess->head.state |= ARTS_CALL_STATE_DESTROY;
    }
}

static void arts_rtsp_shutdown_handler(void *ctx, unsigned int ServerState)
{
    LogRequest(INFO_ARTS_MODULE, 0, "arts_rtsp_shutdown_handler: Shutdown Received ");

    QTSS_Error theErr = QTSS_NoErr;
    if(sServer) 
        theErr = QTSS_SetValue(sServer, qtssSvrState , 0, &ServerState, sizeof(ServerState));
    Assert(theErr == QTSS_NoErr);
}


// Handle Flush
static void arts_rtsp_flush_handler(void *ctx, arts_session *p_sess, unsigned int flush)
{
    //ARTS_PH_Interface *srv = (ARTS_PH_Interface *) ctx;
    LogRequest(INFO_ARTS_MODULE, p_sess->callid, "Flush Received");

    if(flush)
    {
       p_sess->vid_discont = 1;
       p_sess->aud_discont = 1;
       p_sess->flush_discont = 1;
          
    }
}

static arts_system_load_state arts_rtsp_loadstatus_handler()
{

   QTSServerInterface* theServer = QTSServerInterface::GetServer();
   QTSS_ServerState theServerState = theServer->GetServerState();
          
   //we may want to deny this connection for a couple of different reasons
   //if the server is refusing new connections
   if ((theServerState == qtssRefusingConnectionsState) ||
                      (theServerState == qtssIdleState) ||
                (theServerState == qtssFatalErrorState) ||
                  (theServerState == qtssShuttingDownState))
   return OVERLOADED;    

   //if the max connection limit has been hit    
   SInt32 maxConns = theServer->GetPrefs()->GetMaxConnections();
   
   if (maxConns > -1) // limit connections
   { 
    UInt32 maxConnections = (UInt32) maxConns;
    if  ( (theServer->GetNumRTPSessions() >= maxConnections)|| 
          ( theServer->GetNumRTSPSessions() + theServer->GetNumRTSPHTTPSessions() >= maxConnections )) 
    {
     return OVERLOADED;         
    }
   }  
            
   //if the max bandwidth limit has been hit
   SInt32 maxKBits = theServer->GetPrefs()->GetMaxKBitsBandwidth();
   if ( (maxKBits > -1) && (theServer->GetCurBandwidthInBits() >= ((UInt32)maxKBits*1024)) )
   return OVERLOADED;

   return NOTOVERLOADED;                           

}    


//------------------------------------------------------------------------
// MODULE FUNCTIONS IMPLEMENTATION
//------------------------------------------------------------------------


QTSS_Error ARTS_RequestEvent(Task **ppTask)
{
    // First thing to do is to alter the thread's module state to reflect the fact
    // that an event is outstanding.
    QTSS_ModuleState* theState = (QTSS_ModuleState*)OSThread::GetMainThreadData();
    if (OSThread::GetCurrent() != NULL)
        theState = (QTSS_ModuleState*)OSThread::GetCurrent()->GetThreadData();

    if (theState == NULL)
        return QTSS_RequestFailed;

    if (theState->curTask == NULL)
        return QTSS_OutOfState;

    theState->eventRequested = true;
    *ppTask = theState->curTask;
    return QTSS_NoErr;
}

QTSS_Error ARTS_SignalStream(Task *pTask,int event)
{
    if (pTask != NULL)
        pTask->Signal(event);
    return QTSS_NoErr;
}

QTSS_Error ARTSRTSPModule_Main(void* inPrivateArgs)
{
    return _stublibrary_main(inPrivateArgs, ARTSRTSPModuleDispatch);
}

// Dispatch this module's role call back.
QTSS_Error ARTSRTSPModuleDispatch(QTSS_Role inRole, QTSS_RoleParamPtr inParams)
{
    switch (inRole)
    {
        case QTSS_Register_Role:
            return Register(&inParams->regParams);
        case QTSS_Initialize_Role:
            return Initialize(&inParams->initParams);
        case QTSS_RereadPrefs_Role:
            return RereadPrefs();
        case QTSS_Shutdown_Role:
            return Shutdown();
        case QTSS_RTSPPreProcessor_Role:
            return ProcessRTSPRequest(&inParams->rtspPreProcessorParams);
		case QTSS_RTSPSessionClosing_Role:
			return CloseRTSPSession(&inParams->rtspSessionClosingParams);
        case QTSS_RTPSendPackets_Role:
            return SendPackets(&inParams->rtpSendPacketsParams);
        case QTSS_ClientSessionClosing_Role:{
            //qtss_printf("call DestroySession\n");
            return DestroySession(&inParams->clientSessionClosingParams);
         }
		case QTSS_RTCPProcess_Role:
		    return ProcessRTCPPacket(&inParams->rtcpProcessParams);
	    
    }
    return QTSS_NoErr;
}

// Handle the QTSS_Register role call back.
QTSS_Error Register(QTSS_Register_Params* inParams)
{
   // Do role & attribute setup
    (void)QTSS_AddRole(QTSS_Initialize_Role);
    (void)QTSS_AddRole(QTSS_RereadPrefs_Role);
    (void)QTSS_AddRole(QTSS_Shutdown_Role);
    (void)QTSS_AddRole(QTSS_RTSPPreProcessor_Role);
	(void)QTSS_AddRole(QTSS_RTSPSessionClosing_Role);
    (void)QTSS_AddRole(QTSS_RTPSendPackets_Role);   
    (void)QTSS_AddRole(QTSS_ClientSessionClosing_Role);
	(void)QTSS_AddRole(QTSS_RTCPProcess_Role);
    
    // Add an Client session attribute for tracking ARTSSession objects
    static char* sARTSSessionName    = "ARTSRTSPModuleSession";

    (void)QTSS_AddStaticAttribute(qtssClientSessionObjectType, sARTSSessionName, NULL, qtssAttrDataTypeUInt32);
    (void)QTSS_IDForAttr(qtssClientSessionObjectType, sARTSSessionName, &sARTSSessionAttr);

	//added by lijie, 2010.09.30
    (void)QTSS_AddStaticAttribute(qtssRTSPSessionObjectType, sARTSSessionName, NULL, qtssAttrDataTypeUInt32);
    (void)QTSS_IDForAttr(qtssRTSPSessionObjectType, sARTSSessionName, &sARTSRTSPSessionAttr);
	//jieli
	
    // Tell the server our name!
    static char* sModuleName = "ARTSRTSPModule";
    ::strcpy(inParams->outModuleName, sModuleName);

    return QTSS_NoErr;
}

// Handle the QTSS_Initialize role call back.
QTSS_Error Initialize(QTSS_Initialize_Params* inParams)
{
    QTSS_Error err = QTSS_NoErr;
    sARTSPHInterface = NEW ARTS_PH_Interface();
   
    
    // Setup module utils
    QTSSModuleUtils::Initialize(inParams->inMessages, inParams->inServer, inParams->inErrorLogStream);

    // Get prefs object
    sPrefs = QTSSModuleUtils::GetModulePrefsObject(inParams->inModule);
    sServerPrefs = inParams->inPrefs;
    sServer = inParams->inServer;

    sARTSAccessLog = NEW QTSSARTSAccessLog();
    
    err = RereadPrefs();
   
    if (sARTSAccessLog != NULL && sLogEnabled)
        sARTSAccessLog->EnableLog();

	WriteStartupMessage();
   
	LogRequest(INFO_ARTS_MODULE, 0, "Role = Initialize: System Name = %s", sARTSSystemName);
	qtss_printf("Role = Initialize: System Name = %s", sARTSSystemName);
    
    LogRequest(INFO_ARTS_MODULE, 0, "Role = Initialize: Backends = %s", sARTSBackends);
    qtss_printf("ARTS RTSP Module: Role = Initialize: Backends = %s\n", sARTSBackends);

    LogRequest(INFO_ARTS_MODULE, 0, "Role = Initialize: BindHost = %s", sARTSBindHost);
    qtss_printf("ARTS RTSP Module: Role = Initialize: BindHost = %s\n", sARTSBindHost);
    
    LogRequest(INFO_ARTS_MODULE, 0, "Role = Initialize: ListenPort = %d", sARTSListenPort);
    qtss_printf("ARTS RTSP Module: Role = Initialize: ListenPort = %d\n", sARTSListenPort);

	LogRequest(INFO_ARTS_MODULE, 0, "Role = Initialize: Number HandleDir = %d", sARTSNumHandleDir);
    LogRequest(INFO_ARTS_MODULE, 0,"Role = Initialize: Enable Diffserv = %d",sEnableDiffServ);  

    LogRequest(INFO_ARTS_MODULE, 0,"Role = Initialize: Send RTCP Bye on EOS = %d", sSendRtcpByeOnEos);
    qtss_printf("ARTS RTSP Module: Role = Initialize: Send RTCP Bye on EOS = %d\n", sSendRtcpByeOnEos);
    
    LogRequest(INFO_ARTS_MODULE, 0,"Role = Initialize: Inputfile =%s",sARTSInputFile);
    LogRequest(INFO_ARTS_MODULE, 0,"Role = Initialize: Ipqam_Host =%s",sARTSIpqamHost);
    LogRequest(INFO_ARTS_MODULE, 0,"Role = Initialize: Ipqam_Port=%d",sARTSIpqamPort);
    LogRequest(INFO_ARTS_MODULE, 0,"Role = Initialize: Ipqam_Bitrate=%d",sARTSIpqamBitrate);
    LogRequest(INFO_ARTS_MODULE, 0,"Role = Initialize: suppotherChannel=%d",sARTSSupportOtherChannel);
    
    

	for (UInt32 theIndex = 0; theIndex < sARTSNumHandleDir; theIndex++)
    {
	    qtss_printf("ARTS RTSP Module: Role = Initialize: HandleDir = %s\n", sARTSHandleDir[theIndex]);
		LogRequest(INFO_ARTS_MODULE, 0, "Role = Initialize: HandleDir = %s", sARTSHandleDir[theIndex]);
    }

    if(!sARTSPHInterface->Configure(sARTSBackends, sARTSBindHost, sARTSListenPort))
        return QTSS_RequestFailed;
    if(sARTSIpqamHost!=NULL && strlen(sARTSIpqamHost)>0)
    {
         sARTSSendPktThread = NEW ARTS_Send_Pkt_Thread();
         if(sARTSSendPktThread->Configure(sARTSIpqamHost,sARTSIpqamPort,sARTSIpqamBitrate))
         {
            sARTSSendPktThread->send_ahead_time = sARTSIpqamAheadTime;
            sARTSSendPktThread->send_after_time = sARTSIpqamAfterTime;
            sARTSSendPktThread->Start();
            if(sARTSIpqamBitrate >0)
                MUX_RATE = sARTSIpqamBitrate;
         }
    }
    
    
    
    sARTSPHInterface->Start();

    // Report to the server that this module handles DESCRIBE, SETUP, PLAY, PAUSE, and TEARDOWN
    //static QTSS_RTSPMethod sSupportedMethods[] = { qtssDescribeMethod, qtssSetupMethod, qtssTeardownMethod, 
      //                      qtssPlayMethod, qtssPauseMethod,qtssGetParameterMethod};
	static QTSS_RTSPMethod sSupportedMethods[] = { qtssDescribeMethod, qtssSetupMethod, qtssTeardownMethod, 
                            qtssPlayMethod, qtssGetParameterMethod};
    QTSSModuleUtils::SetupSupportedMethods(inParams->inServer, sSupportedMethods, 5);

    return err;
}

QTSS_Error GetARTSHandleDir()
{
    QTSS_Object theAttrInfo = NULL;
    QTSS_Error theErr = QTSS_GetAttrInfoByName(sPrefs, "arts_handledir", &theAttrInfo);
    if (theErr != QTSS_NoErr)
	    return qtssIllegalAttrID;
   
    QTSS_AttrDataType theAttributeType = qtssAttrDataTypeUnknown;
    UInt32 theLen = sizeof(theAttributeType);
   
    QTSS_AttributeID theID = qtssIllegalAttrID; 
    theLen = sizeof(theID);
    theErr = QTSS_GetValue(theAttrInfo, qtssAttrID, 0 , &theID, &theLen);
    Assert(theErr == QTSS_NoErr);

    QTSS_GetNumValues(sPrefs, theID, &sARTSNumHandleDir);
    Assert(theErr == QTSS_NoErr);    

    if (sARTSNumHandleDir == 0)
        return NULL;

    for (UInt32 theIndex = 0; theIndex < sARTSNumHandleDir; theIndex++)
    {
        theErr = QTSS_NoErr;
        (void)QTSS_GetValueAsString((QTSS_Object)sPrefs, theID, theIndex, &sARTSHandleDir[theIndex]);
        Assert(theErr == QTSS_NoErr);   
    }
	return QTSS_NoErr;
}


// Handle the QTSS_RereadPrefs_Role role call back.
QTSS_Error RereadPrefs()
{
    delete [] sDefaultLogDir;
    (void)QTSS_GetValueAsString(sServerPrefs, qtssPrefsErrorLogDir, 0, &sDefaultLogDir);

    delete [] sLogName;
    sLogName = QTSSModuleUtils::GetStringAttribute(sPrefs, "arts_request_logfile_name", sDefaultLogName);
    
    delete [] sLogDir;
    sLogDir  =  QTSSModuleUtils::GetStringAttribute(sPrefs, "arts_request_logfile_dir", sDefaultLogDir);

    delete [] sARTSSystemName;
    sARTSSystemName = QTSSModuleUtils::GetStringAttribute(sPrefs, "arts_systemname", sDefaultARTSSystemName);

    delete [] sARTSBackends;
    sARTSBackends = QTSSModuleUtils::GetStringAttribute(sPrefs, "arts_backends", sDefaultARTSBackends);

    delete [] sARTSBindHost;
    sARTSBindHost = QTSSModuleUtils::GetStringAttribute(sPrefs, "arts_bindhost", sDefaultARTSBindHost);
    
    delete [] sARTSIpqamHost;
    sARTSIpqamHost = QTSSModuleUtils::GetStringAttribute(sPrefs, "arts_ipqam_host", sDefaultARTSBindHost);
    
    delete [] sARTSInputFile;
    sARTSInputFile = QTSSModuleUtils::GetStringAttribute(sPrefs, "arts_inputfile", sDefaultARTSBindHost);
    
    
    QTSSModuleUtils::GetAttribute(sPrefs, "arts_ipqam_port",  qtssAttrDataTypeUInt16,
                                &sARTSIpqamPort, &sDefaultARTSListenPort, sizeof(sARTSListenPort));
    QTSSModuleUtils::GetAttribute(sPrefs, "arts_ipqam_send_bitrate", qtssAttrDataTypeUInt32,
                                &sARTSIpqamBitrate, &sDefaultRollInterval, sizeof(sRollInterval));
                                
    QTSSModuleUtils::GetAttribute(sPrefs, "arts_ipqam_send_ahead_time", qtssAttrDataTypeUInt32,
                                &sARTSIpqamAheadTime, &sDefaultRollInterval, sizeof(sARTSIpqamAheadTime));
                                
    QTSSModuleUtils::GetAttribute(sPrefs, "arts_ipqam_send_after_time", qtssAttrDataTypeUInt32,
                                &sARTSIpqamAfterTime, &sDefaultRollInterval, sizeof(sARTSIpqamAfterTime));                            
    
    QTSSModuleUtils::GetAttribute(sPrefs, "arts_listenport",  qtssAttrDataTypeUInt16,
                                &sARTSListenPort, &sDefaultARTSListenPort, sizeof(sARTSListenPort));

    QTSSModuleUtils::GetAttribute(sPrefs, "arts_request_logging", qtssAttrDataTypeBool16,
                                &sLogEnabled, &sDefaultLogEnabled, sizeof(sLogEnabled));
                                
    QTSSModuleUtils::GetAttribute(sPrefs, "arts_support_pts", qtssAttrDataTypeBool16,
                                &sARTSSupportPTS, &sDefaultLogEnabled, sizeof(sARTSSupportPTS));                            
                                
    
    QTSSModuleUtils::GetAttribute(sPrefs, "arts_dump_input_flag", qtssAttrDataTypeBool16,
                                &dump_input, &sDefaultLogEnabled, sizeof(dump_input));
                                
                                
    QTSSModuleUtils::GetAttribute(sPrefs, "arts_dump_output_flag", qtssAttrDataTypeBool16,
                                &dump_output, &sDefaultLogEnabled, sizeof(dump_output));
                                
                                
    QTSSModuleUtils::GetAttribute(sPrefs, "arts_request_logfile_size", qtssAttrDataTypeUInt32,
                                &sMaxLogBytes, &sDefaultMaxLogBytes, sizeof(sMaxLogBytes));

    QTSSModuleUtils::GetAttribute(sPrefs, "arts_request_logfile_interval", qtssAttrDataTypeUInt32,
                                &sRollInterval, &sDefaultRollInterval, sizeof(sRollInterval));

    QTSSModuleUtils::GetAttribute(sPrefs, "arts_request_logtime_in_gmt", qtssAttrDataTypeBool16,
                                &sLogTimeInGMT, &sDefaultLogTimeInGMT, sizeof(sLogTimeInGMT));

    QTSSModuleUtils::GetAttribute(sPrefs, "arts_enable_diffserv", qtssAttrDataTypeBool16,
                                &sEnableDiffServ, &sDefaultEnableDiffServ, sizeof(sEnableDiffServ));
           
   QTSSModuleUtils::GetAttribute(sPrefs, "arts_support_other_channel", qtssAttrDataTypeBool16,
                                &sARTSSupportOtherChannel, &sDefaultLogEnabled, sizeof(sARTSSupportOtherChannel));                     
                                
    
    QTSSModuleUtils::GetAttribute(sPrefs, "arts_dscp",  qtssAttrDataTypeUInt16,
                                            &sARTSDSCP, &sDefaultDSCP, sizeof(sARTSDSCP));
   QTSSModuleUtils::GetAttribute(sPrefs, "arts_ipqam_pcr_retransmit_time", qtssAttrDataTypeUInt32,
                                &sARTSIpqamPCRInterval, &sARTSIpqamDefaultPCRInterval, sizeof(sARTSIpqamPCRInterval));

    QTSSModuleUtils::GetAttribute(sPrefs,"arts_send_rtcp_bye_on_eos", qtssAttrDataTypeBool16,
                                &sSendRtcpByeOnEos, &sDefaultSendRtcpByeOnEos, sizeof(sSendRtcpByeOnEos));
    // handle changing the sLogEnabled state of the access log.
    if (sARTSAccessLog != NULL)
    {
        if (sLogEnabled)
        {
            if (!sARTSAccessLog->IsLogEnabled())
                sARTSAccessLog->EnableLog();
        }
        else
        {
            if (sARTSAccessLog->IsLogEnabled())
                sARTSAccessLog->CloseLog();
        }
    }

    GetARTSHandleDir();

    return QTSS_NoErr;
}

QTSS_Error ProcessRTSPRequest(QTSS_StandardRTSP_Params* inParams)
{
    QTSS_RTSPMethod* theMethod = NULL;
    UInt32 theMethodLen = 0;
    if ((QTSS_GetValuePtr(inParams->inRTSPRequest, qtssRTSPReqMethod, 0,
            (void**)&theMethod, &theMethodLen) != QTSS_NoErr) || (theMethodLen != sizeof(QTSS_RTSPMethod)))
    {
        Assert(false);
        return QTSS_RequestFailed;
    }

    switch (*theMethod)
    {
        case qtssDescribeMethod:
            return DoDescribe(inParams);
        case qtssSetupMethod:
            return DoSetup(inParams);
        case qtssPlayMethod:
            return DoPlay(inParams);
        case qtssTeardownMethod:
            // Tell the server that this session should be killed, and send a TEARDOWN response
            //qtss_printf("QTSS_Teardown--ProcessRTSPRequest\n");
            (void)QTSS_Teardown(inParams->inClientSession);
            //qtss_printf("sendrtspResponse\n");
            (void)QTSS_SendStandardRTSPResponse(inParams->inRTSPRequest, inParams->inClientSession, 0);
            break;
        case qtssPauseMethod:
             return DoPause(inParams);
             break;
        case qtssGetParameterMethod:
            //(void)QTSS_SendStandardRTSPResponse(inParams->inRTSPRequest, inParams->inClientSession, 0);
            return DoGetParameter(inParams);
            break;
            
        case qtssValidateMethod:
             return DoDefault(inParams);
                    
        default:
            break;
    }

    return QTSS_NoErr;
}


QTSS_Error DoDefault(QTSS_StandardRTSP_Params* inParams)
{
    LogRequest(INFO_ARTS_MODULE, 0,"entry");
    
    
    if(inParams->inRTSPHeaders != NULL)
    {
        QTSSDictionary *headerDict = (QTSSDictionary* )inParams->inRTSPHeaders;
        StrPtrLen *theKeySessionID=headerDict->GetValue(qtssVaryHeader);
        RTSPSessionInterface * theRTSPSess =(RTSPSessionInterface *) inParams->inRTSPSession;
         
        LogRequest(DEBUG_ARTS_MODULE, 0,"RTSPSession:%x",theRTSPSess);
        RTPSession * theRtpSession  = (RTPSession *) inParams->inClientSession;
        Assert(theRTSPSess !=NULL && theRtpSession !=NULL);
            
        
        
        LogRequest(DEBUG_ARTS_MODULE, 0,"CancelTimeout");
            
        
        if(theKeySessionID!= NULL && theKeySessionID->Len >0)
        {
                      
            co_socket_t *sockstruct = (co_socket_t *)malloc(sizeof(co_socket_t));
            memset(sockstruct,0,sizeof(co_socket_t));
            //save the sessionId and the RTSPSessionObj
            char *sessionCStr = theKeySessionID->GetAsCString();
            memcpy(sockstruct->sessionID,sessionCStr,strlen(sessionCStr));
            
            sockstruct->sock =theRTSPSess->GetOutputStream()->GetSocket();          
            sockstruct->used = false; 
            sockstruct->next = NULL;
            sockstruct->rtspSessObj=(RTSPSession*)  inParams->inRTSPSession; 
            sockstruct->rtpSessObj =(RTPSession*) inParams->inClientSession;     
            
            LogRequest(DEBUG_ARTS_MODULE, 0,"validate header sessionID:%s",theKeySessionID->GetAsCString());
            
            //OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
            if(sARTSPHInterface->co_socket_list == NULL)
            {
                sARTSPHInterface->co_socket_list = sockstruct;
                LogRequest(DEBUG_ARTS_MODULE, 0,"sARTSPHInterface->co_socket_list:%x",sARTSPHInterface->co_socket_list);
            }else
            {
                co_socket_t *p = sARTSPHInterface->co_socket_list;
                while(p->next)
                    p = (co_socket_t*)p->next;  
                    
                p->next =sockstruct;                
            }
        }
    }
    
    
    QTSS_SendStandardRTSPResponse(inParams->inRTSPRequest, inParams->inClientSession, 0);
    LogRequest(INFO_ARTS_MODULE, 0,"exit");
    
    return QTSS_NoErr;    
}

QTSS_Error DoGetParameter(QTSS_StandardRTSP_Params* inParams)
{
    QTSS_Error err = QTSS_NoErr;
    QTSS_ClientSessionObject theClientSession = inParams->inClientSession;
    //write x-Accept-Dynamic-Rate header
    //char noticeStr[5]="2101";
    //(void)QTSS_AppendRTSPHeader(inParams->inRTSPRequest, qtssXNoticeHeader,
    //                            noticeStr,strlen(noticeStr));
    UInt32 l_callid = 0, l_len = sizeof(UInt32);
    arts_session *sess = NULL;
    err = QTSS_GetValue(theClientSession, sARTSSessionAttr, 0, (void *)&l_callid, &l_len);

    LogRequest(INFO_ARTS_MODULE, l_callid, "DoGetParameter: Entering ");	

    if(err == QTSS_NoErr)
    {
      //OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
      sess = arts_session_find(l_callid);  
    }
	
     //if(!sess)
       //return QTSS_NoErr;  

    if(sess)
    {
        sess->LastGetParameterTime = QTSS_MilliSecsTo1970Secs(QTSS_Milliseconds());;   
    }    
    (void)QTSS_SendStandardRTSPResponse(inParams->inRTSPRequest, inParams->inClientSession, 0);
    
    
    LogRequest(INFO_ARTS_MODULE, l_callid, "DoGetParameter: Exiting ");
    
    return QTSS_NoErr;
}



QTSS_Error DoDescribe(QTSS_StandardRTSP_Params* inParams)
{
    
    LogRequest(INFO_ARTS_MODULE, 0, "DoDescribe: Entering ");

    QTSS_Error err = QTSS_NoErr;
    QTSS_RTSPRequestObject theRequest = inParams->inRTSPRequest;
    QTSS_ClientSessionObject theClientSession = inParams->inClientSession;
    
    
    
    // Get the full RTSP request from the server's attribute.
    char *theRequestAttributes = NULL;
    UInt32 attributeLen = 0;
    err = QTSS_GetValueAsString(theRequest, qtssRTSPReqFilePathTrunc, 0, &theRequestAttributes);

    if (err != QTSS_NoErr)
    {
        return QTSS_NoErr;
    }

    char *theTransportHeader = NULL;
    err = QTSS_GetValueAsString(theRequest, qtssRTSPReqTransportType, 0, &theTransportHeader);

    if (err != QTSS_NoErr)
    {
        return QTSS_NoErr;
    }

    LogRequest(INFO_ARTS_MODULE, 0, "DoDescribe: Role = QTSS_RTSPPreProcessor_Role: Path = %s", theRequestAttributes);

    if(sARTSNumHandleDir == 0 )
    {
		LogRequest(INFO_ARTS_MODULE, 0, "DoDescribe: Role = No Handle Dir In Pref");
		return QTSS_NoErr;
    }
	
    for (UInt32 theIndex = 0; theIndex < sARTSNumHandleDir; theIndex++)
    {
		if(sARTSHandleDir[theIndex]!= NULL)
		{
			int len = strlen( sARTSHandleDir[theIndex] );// + 1;
		
			if(! strncmp(theRequestAttributes, sARTSHandleDir[theIndex], len))
				break;
		}
		if(theIndex == (sARTSNumHandleDir - 1))
			return QTSS_NoErr;	
    }

    LogRequest(INFO_ARTS_MODULE, 0, "Role = OpenFilePreprocess: Ourfile");

    QTSS_Delete(theRequestAttributes);
	
	QTSS_RTSPSessionType theSessionType = qtssRTSPSession;
	UInt32 theSessionLen = sizeof(theSessionType);
	
	QTSS_GetValue(inParams->inRTSPSession, qtssRTSPSesType, 0, (void*)&theSessionType, &theSessionLen);
    // This is important. Check controller state and proceed only if state ACTIVE.
    // Now it is possible that by the time the connnection request is sent, the 
    // controller will go down. But retries are done only after 10s, so we should be
    // ok, in that the connection request will fail but the send on the socket doesnt
    // need to be protected.
    if (sARTSPHInterface->control_state != ARTS_CONTROLLER_STATE_ACTIVE)
    {
    	if( theSessionType == qtssRTSPSession)
			 QTSSModuleUtils::SendErrorResponseWithMessage(inParams->inRTSPRequest, qtssServerUnavailable, 0);
	
		if( theSessionType == qtssRTSPHTTPSession)
			QTSSModuleUtils::SendHTTPErrorResponse(inParams->inRTSPRequest,qtssServerUnavailable,true, NULL);
        return QTSS_RequestFailed;
    }

    UInt32 l_callid = 0, l_len = sizeof(UInt32);
    arts_session *sess = NULL;
    err = QTSS_GetValue(theClientSession, sARTSSessionAttr, 0, (void *)&l_callid, &l_len);


    if(err == QTSS_NoErr)
    {
       // OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
        sess = arts_session_find(l_callid);  

        LogRequest(INFO_ARTS_MODULE, l_callid, "Found session");
    }
    
    if(!sess)
    {
        arts_ph_callparams callparams;       /* Call Params Struct */
        {
           // OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
            //sARTSPHInterface->callid++;
            sARTSPHInterface->callid += 16; // Last 4 bits should always be zero
            //if(sARTSPHInterface->callid == 0xffffff)
            if(sARTSPHInterface->callid >= 0xffff0) //20 bits only
                sARTSPHInterface->callid = 16;

            l_callid = sARTSPHInterface->callid | sARTSPHInterface->phid << 24;
            sess = arts_session_init(l_callid);
	    }
        

        Assert(sess != NULL);
        if ( sess == NULL )
        {
            LogRequest(INFO_ARTS_MODULE, l_callid, "sess == NULL:1286");
            return QTSS_RequestFailed;
        }
        
        QTSS_RTSPHeaderObject theHeader = inParams->inRTSPHeaders;
        QTSS_RTSPSessionObject theRTSPSession = inParams->inRTSPSession;

        memset(&callparams, 0, sizeof(callparams));
        callparams.callid = l_callid;
        callparams.listenport = sARTSPHInterface->listenport; 

        sess->RTSP_Session_Type = theSessionType;
	    LogRequest(INFO_ARTS_MODULE, l_callid, "session Type = %d", sess->RTSP_Session_Type);

        
        err = QTSS_GetValuePtr(theRequest, qtssRTSPReqAbsoluteURL, 0, (void **)&theRequestAttributes, &attributeLen);

        if(err == QTSS_NoErr)
            strncpy(callparams.requestURI, theRequestAttributes, attributeLen);

        err = QTSS_GetValuePtr(theRequest, qtssRTSPReqQueryString, 0, (void **)&theRequestAttributes, &attributeLen);

        if(err == QTSS_NoErr)
            strncpy(callparams.queryString, theRequestAttributes, attributeLen);

        if(strstr(callparams.queryString,"mux=mp2ts"))
            sess->transport_type = qtssRTPTransportTypeMPEG2;

        err = QTSS_GetValuePtr(theRTSPSession, qtssRTSPSesRemoteAddrStr, 0, (void **)&theRequestAttributes, &attributeLen);

        if(err == QTSS_NoErr)
            strncpy(callparams.clientIP, theRequestAttributes, attributeLen);

        err = QTSS_GetValuePtr(theClientSession, qtssCliSesFirstUserAgent, 0, (void **)&theRequestAttributes, &attributeLen);

        if(err == QTSS_NoErr)
            strncpy(callparams.userAgent, theRequestAttributes, attributeLen);

        err = QTSS_GetValuePtr(sServer, qtssSvrServerName, 0, (void **)&theRequestAttributes, &attributeLen);

        if(err == QTSS_NoErr)
            strncpy(callparams.serverName, theRequestAttributes, attributeLen);

        err = QTSS_GetValuePtr(theRTSPSession, qtssRTSPSesLocalAddrStr, 0, (void **)&theRequestAttributes, &attributeLen);

        if(err == QTSS_NoErr)
            strncpy(callparams.serverHost, theRequestAttributes, attributeLen);

        UInt16 localPort=0;
        attributeLen = sizeof(localPort);
        err = QTSS_GetValue(theRTSPSession, qtssRTSPSesLocalPort, 0, (void *)&localPort, &attributeLen);

        if(err == QTSS_NoErr)
            sprintf(callparams.serverPort, "%d", localPort);

        strcpy(callparams.serverProtocol, "RTSP 1.0");

        err = QTSS_GetValuePtr(theHeader, qtssBandwidthHeader, 0, (void**)&theRequestAttributes, &attributeLen);
        
        if(err == QTSS_NoErr)
          strncpy(callparams.Bandwidth, theRequestAttributes, attributeLen);
        
       // new headers
        
        err = QTSS_GetValuePtr(theHeader, qtssXWapProfileHeader, 0,(void**)&theRequestAttributes,&attributeLen);
        
        if(err == QTSS_NoErr)
          {
           strncpy(callparams.xWapProfile,theRequestAttributes,attributeLen);
           callparams.xWapProfile[attributeLen]='\0';
          }

        err = QTSS_GetValuePtr(theHeader, qtssXWapProfileDiffHeader, 0,(void **)&theRequestAttributes,&attributeLen);
        
        if(err == QTSS_NoErr)
          {
           strncpy(callparams.xWapProfileDiff,theRequestAttributes,attributeLen);
           callparams.xWapProfileDiff[attributeLen]='\0';
          }
		
		    
		//added by lijie, 2010.09.30	  
		err = QTSS_SetValue(theRTSPSession, sARTSRTSPSessionAttr, 0, (void *)&l_callid, sizeof(UInt32));	  
		Assert(err == QTSS_NoErr);
	    //jieli
        err = QTSS_SetValue(theClientSession, sARTSSessionAttr, 0, (void *)&l_callid, sizeof(UInt32));
        Assert(err == QTSS_NoErr);
        sess->remote_con = theClientSession;
        sess->RTSPRequest = theRequest;



        if(arts_send_conreq(sARTSPHInterface->controlsock->fd, &callparams) == -1)
        {
			if( sess->RTSP_Session_Type == qtssRTSPSession)
				 QTSSModuleUtils::SendErrorResponseWithMessage(inParams->inRTSPRequest, qtssServerUnavailable, 0);
			
			if( sess->RTSP_Session_Type == qtssRTSPHTTPSession)
				QTSSModuleUtils::SendHTTPErrorResponse(inParams->inRTSPRequest,qtssServerUnavailable,true, NULL);

			OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
            arts_session_free(sess, 1);
            LogRequest(INFO_ARTS_MODULE, l_callid, "arts_send_conreq(sARTSPHInterface->controlsock->fd, &callparams) == -1");
	        return QTSS_RequestFailed;
        }
        ARTS_RequestEvent((Task **)&sess->task_ptr);
        LogRequest(INFO_ARTS_MODULE, l_callid, "if(!sess):1392");
        return QTSS_NoErr;
    }

    
	if(sess->head.state == ARTS_CALL_STATE_DESTROY_NOW)
	{
		if( sess->RTSP_Session_Type == qtssRTSPSession)
        {
            
            QTSS_RTSPStatusCode  sCode = RTSPProtocol::GetQTSS_RTSPStatusCode(sess->ReleaseStatusCode);
            if(sCode != 0 )
                QTSSModuleUtils::SendErrorResponseWithMessage(inParams->inRTSPRequest,sCode , 0);
            else
                QTSSModuleUtils::SendErrorResponseWithMessage(inParams->inRTSPRequest,qtssServerUnavailable , 0);
        }
		if( sess->RTSP_Session_Type == qtssRTSPHTTPSession)
			QTSSModuleUtils::SendHTTPErrorResponse(inParams->inRTSPRequest,qtssServerUnavailable,true, NULL);

		OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
		arts_session_free(sess,1);
        LogRequest(INFO_ARTS_MODULE, l_callid, "sess->head.state == ARTS_CALL_STATE_DESTROY_NOW:1412");
		return QTSS_RequestFailed;
	}

    iovec theDescribeVec[3] = { {0 }};
    ResizeableStringFormatter editedSDP(NULL,0);
   

   //   editedSDP.Put("v=0\r\n");
   // editedSDP.Put("a=range:npt=0.00-2000.00\r\n");
   // editedSDP.Put("a=scaleRate:-32,-16,-8,-4,-2,2,4,8,16,32\r\n");

/* 
    char tempBuff[256]= "";
    tempBuff[255] = 0;
    qtss_snprintf(tempBuff,sizeof(tempBuff) - 1, "%lu", (UInt32) sARTSPHInterface->callid);

    editedSDP.Put("o=StreamingServer ");
    editedSDP.Put(tempBuff);
    editedSDP.Put(" ");
    QTSS_TimeVal curTs = QTSS_Milliseconds();
    qtss_snprintf(tempBuff, sizeof(tempBuff) - 1, "%"_64BITARG_"d", (SInt64) (curTs/1000) + 2208988800LU);
    editedSDP.Put(tempBuff);

    editedSDP.Put(" IN IP4 ");
    UInt32 buffLen = sizeof(tempBuff) -1;
    (void)QTSS_GetValue(inParams->inClientSession, qtssCliSesHostName, 0, &tempBuff, &buffLen);
    editedSDP.Put(tempBuff, buffLen);
    editedSDP.PutEOL();

    char* theSDPName = NULL;
    (void)QTSS_GetValueAsString(inParams->inRTSPRequest, qtssRTSPReqFilePath, 0, &theSDPName);
    QTSSCharArrayDeleter thePathStrDeleter(theSDPName);
    editedSDP.Put("s=");
    editedSDP.Put(theSDPName);   
    editedSDP.PutEOL();    

    //editedSDP.Put("o=OnewaveUServerNG 482379710 379429407 IN IP4 192.168.9.10\r\n");
    
    char tempBuff[256]= "";
    tempBuff[255] = 0;
    qtss_snprintf(tempBuff,sizeof(tempBuff) - 1, "%lu", (UInt32) sARTSPHInterface->callid);

    editedSDP.Put("o=OnewaveUServerEagle 546391184 265606183");
    //editedSDP.Put(tempBuff);
    //editedSDP.Put(" ");
    //QTSS_TimeVal curTs = QTSS_Milliseconds();
    //qtss_snprintf(tempBuff, sizeof(tempBuff) - 1, "%"_64BITARG_"d", (SInt64) (curTs/1000) + 2208988800LU);
    //editedSDP.Put(tempBuff);
    editedSDP.Put(" IN IP4 ");
    editedSDP.Put("192.168.0.107\r\n");
    
    editedSDP.Put("s=rtsp://192.168.0.107:554/ARTS/PT/youku-2493898fb9be4d4fc70581a16373ab0dd.ts?Contentid=00000000000000000000000004024971&token=5FBDEC9752A73D7986DFCD5F463104D798CE443DF170DA6E068AC8D510FFA716EA60F6498C2FF85DC082C7F238A7877F449810EF17196CA0825DD8B68EFDB0B871B22B689F34C31D6BD4A779D925B5F0E9488A3ED4364B9A1BE3EA997FA055FC1BB27BB612723AF72756DDA22A5E086B70EAB1D03E1F796E1A91BD255FC1AD07AE2C1B5FC0DA4E8154C99640CF58BDC66A5FCDE640C20336713761D8D27BA41557954E3537CC5DFFD60DF5EA9186CC634233797CAD5C34F1CF5CF2BFFB1F53CD1F2FC9E2674F2022F04D75952E492CF7DE5A8005299AF8E2BC580BE3CA2CB86D15CCEFC9CA7B3C764396DCEF144E2DFE1C24B150A480E37867C9432B6DF776CF363293F3CF9CE6287C1CCA3B2D4F2A3763B7C2F3BFCDCC25184A822D90240DB55204DEE7A2C83C1A39E56CB8A7CE1A5D945BBA39259092B751CDA31C56CA01E07676AF2A47C09C97CC65A1B4614E961D72E53AC841CC073F87861E26FAED3D65D9&isHD=0&isIpqam=0&servicetype=1&mode=2&owchid=vod01_channel&owsid=1298162865366446072\r\n");
    editedSDP.Put("u=http:///\r\n");
    editedSDP.Put("e=admin@\r\n");
    editedSDP.Put("c=IN IP4 0.0.0.0\r\n");
    editedSDP.Put("t=0 0\r\n");    
    editedSDP.Put("a=isma-compliance:1,1.0,1\r\n\r\n");
    editedSDP.Put("a=range:npt=0.000000-95.160000\r\n");
    
    editedSDP.Put("a=x-bitrate: 1868404\r\n");
    editedSDP.Put("m=video 0 MP2T mpgv\r\n");
    editedSDP.Put("a=control:trackID=0\r\n");
    editedSDP.Put("m=audio 0 MP2T mpga\r\n");
    editedSDP.Put("a=control:trackID=1\r\n");
    
    
    //editedSDP.Put("m=video 0 RTP/AVP 96\r\n");    
    //editedSDP.Put("a=control:trackID=1\r\n");
    
    //editedSDP.Put("a=rtpmap:96 H264/90000\r\n");
    //editedSDP.Put("a=fmtp:96 profile-level-id=6742c0; sprop-parameter-sets=Z0LAFNoHRWwEQAAAAwBAAAAMg8UKqA==,aM4xMg==; packetization-mode=1\r\n");
    //editedSDP.Put("a=fmtp:96 profile-level-id=420016; sprop-parameter-sets=Z0IAFpZkBaCSQgAAAwACAAADADMI,aM48gA==; packetization-mode=1\r\n");
    //editedSDP.Put("a=fmtp:96 profile-level-id=42c014; sprop-parameter-sets=Z0LAFNoHRWwEQAAAAwBAAAAMg8UKqA==,aM4xMg==; packetization-mode=1\r\n");
    //editedSDP.Put("m=audio 0 RTP/AVP 97\r\n");
    //editedSDP.Put("a=rtpmap:97 mpeg4-generic/44100/2\r\n");
    
    //editedSDP.Put("a=control:trackID=2\r\n");
   // editedSDP.Put("a=mpeg4-esid:3\r\n");
   // editedSDP.Put("a=fmtp:97 streamtype=5; profile-level-id=15; mode=AAC-hbr; config=1210; SizeLength=13; IndexLength=3; IndexDeltaLength=3; Profile=1;\r\n");

/**/
    static char *l_sdpName = "Content-Body";
    
    for ( int l_Index = 0 ; l_Index < sess->numKeyValuePairs; l_Index++)
    {
        if(sess->keyValuePairs[l_Index].name && 
            sess->keyValuePairs[l_Index].value)
        {
            if(strcmp(l_sdpName,sess->keyValuePairs[l_Index].name) == 0) 
            {
                editedSDP.Put(sess->keyValuePairs[l_Index].value);
       
            }
        }  
    }

/*
    UInt32  total_len= editedSDP.GetBytesWritten();
    StrPtrLen editedSDPSPL(editedSDP.GetBufPtr(),total_len);
    LogRequest(INFO_ARTS_MODULE, l_callid,"total len:%d",total_len); 
 */  
 
 
    StrPtrLen editedSDPSPL(editedSDP.GetBufPtr(),editedSDP.GetBytesWritten());

    SDPContainer checkedSDPContainer;
    checkedSDPContainer.SetSDPBuffer( &editedSDPSPL );
    if (!checkedSDPContainer.IsSDPBufferValid())
    {
        LogRequest(INFO_ARTS_MODULE, l_callid, "!checkedSDPContainer.IsSDPBufferValid():1469");
        return QTSS_RequestFailed;
    }

    SDPLineSorter sortedSDP(&checkedSDPContainer);
    UInt32 sessLen = sortedSDP.GetSessionHeaders()->Len;
    UInt32 mediaLen = sortedSDP.GetMediaHeaders()->Len;

    theDescribeVec[1].iov_base = sortedSDP.GetSessionHeaders()->Ptr;
    theDescribeVec[1].iov_len = sortedSDP.GetSessionHeaders()->Len;

    theDescribeVec[2].iov_base = sortedSDP.GetMediaHeaders()->Ptr;
    theDescribeVec[2].iov_len = sortedSDP.GetMediaHeaders()->Len;

	// Append the Last Modified header to be a good caching proxy citizen before sending the Describe
	
	(void)QTSS_AppendRTSPHeader(inParams->inRTSPRequest, qtssCacheControlHeader,
                                kCacheControlHeader.Ptr, kCacheControlHeader.Len);
                                
	//theDescribeVec[1].iov_base = editedSDP.GetBufPtr();
    //theDescribeVec[1].iov_len = editedSDP.GetBytesWritten();
   
    //UInt32 sessLen = editedSDP.GetBytesWritten();
    //UInt32 mediaLen = 0;
    QTSSModuleUtils::SendDescribeResponse(inParams->inRTSPRequest, inParams->inClientSession,
                                            &theDescribeVec[0], 3, sessLen + mediaLen );
    arts_ph_delete_keyvalues(sess->keyValuePairs, sess->numKeyValuePairs);
    sess->keyValuePairs = NULL;
    sess->numKeyValuePairs = 0;

    LogRequest(INFO_ARTS_MODULE, l_callid, "Exiting");

    return QTSS_NoErr;
}


QTSS_Error DoSetup(QTSS_StandardRTSP_Params* inParams)
{

    QTSS_Error theErr = QTSS_NoErr;
    UInt32 callid, theLen = sizeof(callid);
    char *theRequestAttributes = NULL;
    UInt32 attributeLen = 0;
    QTSS_RTSPHeaderObject       theHeader;
    QTSS_RTSPRequestObject theRequest = inParams->inRTSPRequest;

    QTSS_Error err = QTSS_GetValuePtr(theRequest, qtssRTSPReqFullRequest, 0, (void **)&theRequestAttributes, &attributeLen);

    /*
    if(err == QTSS_NoErr)
        strncpy(callparams.queryString, theRequestAttributes, attributeLen);
    */

    if(theRequestAttributes)
    {
        if(strstr(theRequestAttributes,"MP2T"))
        {
            LogRequest(DEBUG_ARTS_MODULE, 0, "Entering MP2T ");
            return DoDescribeAndSetup(inParams,true);
        }
    }

    theErr = QTSS_GetValue(inParams->inClientSession, sARTSSessionAttr, 0, &callid, &theLen);
    Assert(theErr == QTSS_NoErr);
	arts_session *sess = NULL;
    {
		OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
	    sess = arts_session_find(callid);
    	if(!sess) return QTSS_NoErr;
	}
	


    LogRequest(INFO_ARTS_MODULE, callid, "Entering ");


    //unless there is a digit at the end of this path (representing trackID), don't
    //even bother with the request
    char* theDigitStr = NULL;
    (void)QTSS_GetValueAsString(inParams->inRTSPRequest, qtssRTSPReqFileDigit, 0, &theDigitStr);
    QTSSCharArrayDeleter theDigitStrDeleter(theDigitStr);
    UInt32 theTrackID;
    if(!(sess->transport_type == qtssRTPTransportTypeMPEG2))
    {
        if (theDigitStr == NULL)
        {
            StrPtrLen theErrResponse("ARTS RTSP Module: No TrackID");
            return QTSSModuleUtils::SendErrorResponseWithMessage(inParams->inRTSPRequest,
                                                                 qtssClientBadRequest, &theErrResponse);
        }
        theTrackID = ::strtol(theDigitStr, NULL, 10);
    }
    else
    {
        theTrackID = 1;
    }
    QTSS_RTPPayloadType thePayloadType = qtssUnknownPayloadType;

    //Create a new RTP stream
    QTSS_RTPStreamObject newStream = NULL;
    
     LogRequest(DEBUG_ARTS_MODULE, callid, "--begin addstream");
    theErr = QTSS_AddRTPStream(inParams->inClientSession, inParams->inRTSPRequest, &newStream, 0);
    LogRequest(DEBUG_ARTS_MODULE, callid, "--end addstream,err:%d",theErr);
    if (theErr != QTSS_NoErr)
        return theErr;

    theHeader = inParams->inRTSPHeaders; 
    arts_rtsp_additional_headers rtspHeader;

    memset(&rtspHeader, 0, sizeof(rtspHeader));

    rtspHeader.callid = callid;
    
    strcpy(rtspHeader.method,"Setup");

    err = QTSS_GetValuePtr(theHeader, qtssXWapProfileHeader, 0,(void **)&theRequestAttributes,&attributeLen);
        
    if(err == QTSS_NoErr)
      {
          strncpy(rtspHeader.xWapProfile,theRequestAttributes,attributeLen);
          rtspHeader.xWapProfile[attributeLen] = '\0';
      }      
    err = QTSS_GetValuePtr(theHeader, qtssXWapProfileDiffHeader, 0,(void **)&theRequestAttributes,&attributeLen);
    
    if(err == QTSS_NoErr)
      {
          strncpy(rtspHeader.xWapProfileDiff,theRequestAttributes,attributeLen);
          rtspHeader.xWapProfileDiff[attributeLen] = '\0';
      }    
    err = QTSS_GetValuePtr(theHeader, qtss3GPPLinkCharHeader, 0,(void **)&theRequestAttributes,&attributeLen);

    if(err == QTSS_NoErr)
      {
          strncpy(rtspHeader._3gppLinkChar,theRequestAttributes,attributeLen);
          rtspHeader._3gppLinkChar[attributeLen] = '\0';
      }    
    err = QTSS_GetValuePtr(theHeader, qtss3GPPAdaptationHeader, 0,(void **)&theRequestAttributes,&attributeLen);

    if(err == QTSS_NoErr)
      { 
          strncpy(rtspHeader._3gppAdaptationHeader,theRequestAttributes,attributeLen);
          rtspHeader._3gppAdaptationHeader[attributeLen] = '\0';
      }    
	arts_send_additional_rtsp_Headers(sARTSPHInterface->controlsock->fd, &rtspHeader); //send rtsp headers to controller

           
    switch(theTrackID)
    {
    
    case 0:
        thePayloadType = qtssVideoPayloadType;
        sess->video_str = newStream;
        theErr = QTSS_SetValue(newStream, qtssRTPStrSSRC, 0, &sess->rtp_video_SSRC, sizeof(sess->rtp_video_SSRC));
        
        if(sEnableDiffServ)
        theErr = QTSS_Enable_DiffServ(newStream,sARTSDSCP);  
        
        Assert(theErr == QTSS_NoErr);

        break;
    case 1:
        thePayloadType = qtssAudioPayloadType;
        sess->audio_str = newStream;
        theErr = QTSS_SetValue(newStream, qtssRTPStrSSRC, 0, &sess->rtp_audio_SSRC, sizeof(sess->rtp_audio_SSRC));
       
        if(sEnableDiffServ)
        theErr = QTSS_Enable_DiffServ(newStream,sARTSDSCP);
       
        Assert(theErr == QTSS_NoErr);

        break;
    default:
        return QTSS_RequestFailed;
    }

    theErr = QTSS_SetValue(newStream, qtssRTPStrPayloadType, 0, &thePayloadType, sizeof(thePayloadType));
    Assert(theErr == QTSS_NoErr);

    theErr = QTSS_SetValue(newStream, qtssRTPStrTrackID, 0, &theTrackID, sizeof(theTrackID));
    Assert(theErr == QTSS_NoErr);

    //send the setup response
    char *cacheCStr = "no-cache";
    StrPtrLen cachStr(cacheCStr,strlen(cacheCStr));
    (void)QTSS_AppendRTSPHeader(inParams->inRTSPRequest, qtssCacheControlHeader,
                                cachStr.Ptr, cachStr.Len);
	
    QTSS_SendStandardRTSPResponse(inParams->inRTSPRequest, newStream, 0);
    
    LogRequest(INFO_ARTS_MODULE, callid, "Exiting ");

    return  QTSS_NoErr; 
}
QTSS_Error GetMPEG2StreamPackets(arts_session *sess)
{
    //OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
    LogRequest(DEBUG_ARTS_MODULE, sess->callid, "Entering MPEG2");

    Bool8 first_pkt = false;
        
    if(!sess)
        return QTSS_RequestFailed;

    if(sess->first_packet.pkt_len > 0)
    {
        // There was a packet, so send it to the client
        first_pkt = true;
    }

    rtp_packet_buffer_type  *last_rtp_packet_buffer = NULL;

    rtp_packet_buffer_type *p_rtp_packet_buffer = sess->rtp_packet_buffer;

#if DO_BLOCK_READ
    while( sess->rtp_packet_buffer_len < MAX_RTP_PACKET_BUFFER_LEN )
#else
    while(!first_pkt)
#endif
    {
        SInt32 in = 0;  
        int flags = 0;
        char l_buf[4096];
         
        struct sctp_sndrcvinfo sndrcvinfo;
        in = sctp_recvmsg( sess->head.sock->fd, (void *)l_buf , sizeof(l_buf), (struct sockaddr *)NULL, 0, &sndrcvinfo, &flags );


        if( in <= -1)  //no more data available at this time
        {
            LogRequest(DEBUG_ARTS_MODULE, sess->callid, "No Data available at this time ");
     
#if DO_BLOCK_READ
            return QTSS_NoMoreData;
#else
            return QTSS_RequestFailed; 
#endif
        }
        else if ( in == 0)   //error occured  socket closed 
        {
            LogRequest(DEBUG_ARTS_MODULE, sess->callid, "socket closed");
            return QTSS_RequestFailed; 
        }
        else
        {
#if DO_BLOCK_READ
             sess->rtp_packet_buffer_len++;
#endif
            LogRequest(INFO_ARTS_MODULE, sess->callid, "type = %c sess->rtp_packet_buffer_len  = %d ",TYPE_TO_C(sndrcvinfo.sinfo_stream),sess->rtp_packet_buffer_len);                   
            //Play Response not yet send. Save the packet for later play
            char* first_packet = (char *) malloc(in);
            memcpy(first_packet,l_buf, in);

            rtp_packet_buffer_type *rtp_packet_buffer =(rtp_packet_buffer_type *) malloc(sizeof(rtp_packet_buffer_type));
            rtp_packet_buffer->pkt_buf = first_packet;
            rtp_packet_buffer->pkt_str = sndrcvinfo.sinfo_stream;
            rtp_packet_buffer->pkt_len = in;
            rtp_packet_buffer->next = NULL;

            QTSS_PacketStruct thePacket;
            thePacket.packetData = l_buf;

            first_pkt = true;

            if(last_rtp_packet_buffer == NULL)
            {
                sess->rtp_packet_buffer = rtp_packet_buffer;
                last_rtp_packet_buffer = rtp_packet_buffer;         

            }
            else
            {
                last_rtp_packet_buffer->next = rtp_packet_buffer;
                last_rtp_packet_buffer = rtp_packet_buffer;
            }
        }
    }
    LogRequest(DEBUG_ARTS_MODULE, sess->callid, "Exiting");

    return QTSS_NoErr;
}

QTSS_Error GetStreamPackets(arts_session *sess, bool readAll)
{
    //OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
    LogRequest(DEBUG_ARTS_MODULE, sess->callid, "Entering");

    Bool8 first_audio_pkt = (sess->rtp_media_type & ARTS_AUDIO_SESSION)? false : true;
    Bool8 first_video_pkt = (sess->rtp_media_type & ARTS_VIDEO_SESSION)? false : true;

    //sess->rtp_audio_seqnum = 0xffff;
    //sess->rtp_video_seqnum = 0xffff;
        
    if(!sess)
        return QTSS_RequestFailed;

    
    if(sess->transport_type == qtssRTPTransportTypeMPEG2)
    {
        return GetMPEG2StreamPackets(sess);
    }
    
    if(sess->first_packet.pkt_len > 0)
    {
        // There was a packet, so send it to the client
        QTSS_PacketStruct thePacket;
        thePacket.packetData = sess->first_packet.pkt_buf;
        UInt32* theTimeStampP = (UInt32*)thePacket.packetData;
        UInt32 theTimeStamp = ntohl(theTimeStampP[1]);

        UInt16* theSeqNumP = (UInt16*)thePacket.packetData;
        UInt16 theSeqNum = ntohs(theSeqNumP[1]);
           
        LogRequest(DEBUG_ARTS_MODULE, sess->callid, "first  type = %c seqno = %d timest = %d  ",TYPE_TO_C (sess->first_packet.pkt_str),theSeqNum,theTimeStamp);
        if(sess->first_packet.pkt_str == 2)
        {
           // if(!readAll) sess->rtp_audio_seqnum = (theSeqNum);  // Do not add offset here. Since packet is already existing and so offset would have been processed.
#if ! DO_BLOCK_READ
           // if(!readAll) sess->rtp_audio_timestamp = (theTimeStamp);
#endif
            first_audio_pkt = true;
        }
        else if(sess->first_packet.pkt_str == 3)
        {
           // if(!readAll) sess->rtp_video_seqnum = (theSeqNum);
#if ! DO_BLOCK_READ
           // if(!readAll) sess->rtp_video_timestamp = (theTimeStamp);
#endif
            first_video_pkt = true;               
        }
    }

    rtp_packet_buffer_type  *last_rtp_packet_buffer = NULL;

    rtp_packet_buffer_type *p_rtp_packet_buffer = sess->rtp_packet_buffer;
    while(p_rtp_packet_buffer)
    {
        QTSS_PacketStruct thePacket;
        thePacket.packetData = p_rtp_packet_buffer->pkt_buf;

        UInt32* theTimeStampP = (UInt32*)thePacket.packetData;
        UInt32 theTimeStamp = ntohl(theTimeStampP[1]);

        UInt16* theSeqNumP = (UInt16*)thePacket.packetData;
        UInt16 theSeqNum = ntohs(theSeqNumP[1]);

        LogRequest(DEBUG_ARTS_MODULE, sess->callid, "type = %c seqno = %d timest = %d  ", TYPE_TO_C (p_rtp_packet_buffer->pkt_str), theSeqNum ,theTimeStamp);                     
        if(!first_audio_pkt   && p_rtp_packet_buffer->pkt_str == 2 )
        {
           //if(!readAll) sess->rtp_audio_seqnum = theSeqNum;        //(theSeqNum + sess->aud_seqnumOffset);
#if ! DO_BLOCK_READ
           // if(!readAll) sess->rtp_audio_timestamp = theTimeStamp; //(theTimeStamp + sess->aud_ts);
#endif
            first_audio_pkt = true;
        }

        if(!first_video_pkt   && p_rtp_packet_buffer->pkt_str == 3 )
        {
            //if(!readAll) sess->rtp_video_seqnum = theSeqNum; // (theSeqNum + sess->vid_seqnumOffset);
#if ! DO_BLOCK_READ
            //if(!readAll) sess->rtp_video_timestamp = theTimeStamp; //(theTimeStamp + sess->vid_ts);
#endif
            first_video_pkt = true;
        } 

        last_rtp_packet_buffer = p_rtp_packet_buffer;
        p_rtp_packet_buffer = (rtp_packet_buffer_type *)p_rtp_packet_buffer->next;
    }

#if DO_BLOCK_READ
    while( sess->rtp_packet_buffer_len < MAX_RTP_PACKET_BUFFER_LEN )
#else
    while( (!(first_video_pkt  &&  first_audio_pkt )) || readAll)
#endif
    {
        SInt32 in = 0;  
        int flags = 0;
        //int flags = MSG_CONFIRM;
        char l_buf[4096];
         
        struct sctp_sndrcvinfo sndrcvinfo;
        in = sctp_recvmsg( sess->head.sock->fd, (void *)l_buf , sizeof(l_buf), (struct sockaddr *)NULL, 0, &sndrcvinfo, &flags );


        LogRequest(DEBUG_ARTS_MODULE, sess->callid, "Reading Data ");

        if( in <= -1)  //no more data available at this time
        {
            LogRequest(DEBUG_ARTS_MODULE, sess->callid, "No Data available at this time ");
     
#if DO_BLOCK_READ
            return QTSS_NoMoreData;
#else
            return QTSS_RequestFailed; 
#endif
        }
        else if ( in == 0)   //error occured  socket closed 
        {
            LogRequest(DEBUG_ARTS_MODULE, sess->callid, "socket closed");
            return QTSS_RequestFailed; 
        }
        else
        {
#if DO_BLOCK_READ
             sess->rtp_packet_buffer_len++;
#endif
             if(readAll)  sess->rtp_packet_buffer_len++;

             LogRequest(DEBUG_ARTS_MODULE, sess->callid, "type = %c sess->rtp_packet_buffer_len  = %d ",TYPE_TO_C(sndrcvinfo.sinfo_stream),sess->rtp_packet_buffer_len);                   

             //Play Response not yet send. Save the packet for later play
            char* first_packet = (char *) malloc(in);
            memcpy(first_packet,l_buf, in);

            rtp_packet_buffer_type *rtp_packet_buffer =(rtp_packet_buffer_type *) malloc(sizeof(rtp_packet_buffer_type));
            rtp_packet_buffer->pkt_buf = first_packet;
            rtp_packet_buffer->pkt_str = sndrcvinfo.sinfo_stream;
            rtp_packet_buffer->pkt_len = in;
            rtp_packet_buffer->next = NULL;

            QTSS_PacketStruct thePacket;
            thePacket.packetData = l_buf;
            UInt32* theTimeStampP = (UInt32*)thePacket.packetData;
            UInt32 theTimeStamp = ntohl(theTimeStampP[1]);
    
            UInt16* theSeqNumP = (UInt16*)thePacket.packetData;
            UInt16 theSeqNum = ntohs(theSeqNumP[1]);

            //if((theSeqNum == 1)){
            if((theSeqNum == 1) && sess->aud_discont == 1 && sess->vid_discont == 1 && sess->flush_discont == 1){
                //Empty the list   
                LogRequest(INFO_ARTS_MODULE, sess->callid, "Found start of packet Flushing buffer...");                   
                //sess->aud_discont = 1;
                //sess->vid_discont = 1;
                sess->flush_discont = 0;

                p_rtp_packet_buffer = sess->rtp_packet_buffer;
                int count = 0;
                while(p_rtp_packet_buffer){
                    sess->rtp_packet_buffer = (rtp_packet_buffer_type *) sess->rtp_packet_buffer->next;

                    free(p_rtp_packet_buffer->pkt_buf);
                    free(p_rtp_packet_buffer);
                    
                    p_rtp_packet_buffer = sess->rtp_packet_buffer;
                    
                    count++;
                    LogRequest(DEBUG_ARTS_MODULE, sess->callid, "Flushed %d", count);                   
                    sess->rtp_packet_buffer_len--;
                }
                
                last_rtp_packet_buffer = NULL;
            }

            LogRequest(DEBUG_ARTS_MODULE, sess->callid, "type = %c seqno = %d timest = %d  ",TYPE_TO_C(sndrcvinfo.sinfo_stream),theSeqNum,theTimeStamp);                   

            if(!first_audio_pkt   && sndrcvinfo.sinfo_stream == 2 )
            {
             // if(!readAll)  sess->rtp_audio_seqnum = theSeqNum;  //(theSeqNum + sess->aud_seqnumOffset);
#if ! DO_BLOCK_READ
             //  if(!readAll) sess->rtp_audio_timestamp = theTimeStamp; //(theTimeStamp + sess->aud_ts);
#endif
                first_audio_pkt = true;
            }

            if(!first_video_pkt   && sndrcvinfo.sinfo_stream == 3 )
            {
              //if(!readAll)  sess->rtp_video_seqnum = theSeqNum; //(theSeqNum + sess->vid_seqnumOffset);
#if ! DO_BLOCK_READ
              // if(!readAll) sess->rtp_video_timestamp = theTimeStamp; //(theTimeStamp + sess->vid_ts);
#endif
                first_video_pkt = true;
            }     

            if(last_rtp_packet_buffer == NULL)
            {
                sess->rtp_packet_buffer = rtp_packet_buffer;
                last_rtp_packet_buffer = rtp_packet_buffer;         

            }
            else
            {
                last_rtp_packet_buffer->next = rtp_packet_buffer;
                last_rtp_packet_buffer = rtp_packet_buffer;
            }
        }
    }
    LogRequest(DEBUG_ARTS_MODULE, sess->callid, "Exiting");

    return QTSS_NoErr;
}




QTSS_Error DoDescribeAndSetup(QTSS_StandardRTSP_Params* inParams,bool isMP2TSFlag)
{
    LogRequest(INFO_ARTS_MODULE, 0, "DoDescribeAndSetup: Entering ");

    QTSS_Error err = QTSS_NoErr;
    QTSS_RTSPRequestObject theRequest = inParams->inRTSPRequest;
    QTSS_ClientSessionObject theClientSession = inParams->inClientSession;
    
    
    RTSPSessionInterface * theRTSPSess = (RTSPSessionInterface*)inParams->inRTSPSession;
    if(sARTSSupportOtherChannel == true)
    {
        LogRequest(INFO_ARTS_MODULE, 0, "Entry double rtsp connection  mode");
        if(theRTSPSess!=NULL)
            theRTSPSess->SetSupportOtherChannel();
    }

    // Get the full RTSP request from the server's attribute.
    char *theRequestAttributes = NULL;
    UInt32 attributeLen = 0;
    err = QTSS_GetValueAsString(theRequest, qtssRTSPReqFilePathTrunc, 0, &theRequestAttributes);

    if (err != QTSS_NoErr)
    {
        return QTSS_NoErr;
    }

    LogRequest(INFO_ARTS_MODULE, 0, "DoDescribe: Role = QTSS_RTSPPreProcessor_Role: Path = %s", theRequestAttributes);

    if(sARTSNumHandleDir == 0 )
    {
		LogRequest(INFO_ARTS_MODULE, 0, "DoDescribe: Role = No Handle Dir In Pref");
		return QTSS_NoErr;
    }
	
    for (UInt32 theIndex = 0; theIndex < sARTSNumHandleDir; theIndex++)
    {
		if(sARTSHandleDir[theIndex]!= NULL)
		{
			int len = strlen( sARTSHandleDir[theIndex] );// + 1;
		
			if(! strncmp(theRequestAttributes, sARTSHandleDir[theIndex], len))
				break;
		}
		if(theIndex == (sARTSNumHandleDir - 1))
			return QTSS_NoErr;	
    }

    LogRequest(INFO_ARTS_MODULE, 0, "Role = OpenFilePreprocess: Ourfile");

    QTSS_Delete(theRequestAttributes);
	
	QTSS_RTSPSessionType theSessionType = qtssRTSPSession;
	UInt32 theSessionLen = sizeof(theSessionType);
	
	QTSS_GetValue(inParams->inRTSPSession, qtssRTSPSesType, 0, (void*)&theSessionType, &theSessionLen);


    // This is important. Check controller state and proceed only if state ACTIVE.
    // Now it is possible that by the time the connnection request is sent, the 
    // controller will go down. But retries are done only after 10s, so we should be
    // ok, in that the connection request will fail but the send on the socket doesnt
    // need to be protected.custom_st
    if (sARTSPHInterface->control_state != ARTS_CONTROLLER_STATE_ACTIVE)
    {
    	if( theSessionType == qtssRTSPSession)
			 QTSSModuleUtils::SendErrorResponseWithMessage(inParams->inRTSPRequest, qtssServerUnavailable, 0);
	
		if( theSessionType == qtssRTSPHTTPSession)
			QTSSModuleUtils::SendHTTPErrorResponse(inParams->inRTSPRequest,qtssServerUnavailable,true, NULL);
        return QTSS_RequestFailed;
    }

    UInt32 l_callid = 0, l_len = sizeof(UInt32);
    arts_session *sess = NULL;
    err = QTSS_GetValue(theClientSession, sARTSSessionAttr, 0, (void *)&l_callid, &l_len);


    if(err == QTSS_NoErr)
    {
        OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
        sess = arts_session_find(l_callid);  

        LogRequest(DEBUG_ARTS_MODULE, l_callid, "Found session");
    }

    if(!sess)
    {
        arts_ph_callparams callparams;       /* Call Params Struct */
        {
            OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
            //sARTSPHInterface->callid++;
            sARTSPHInterface->callid += 16; // Last 4 bits should always be zero
            //if(sARTSPHInterface->callid == 0xffffff)
            if(sARTSPHInterface->callid == 0xfffff) //20 bits only
                sARTSPHInterface->callid = 16;

            l_callid = sARTSPHInterface->callid | sARTSPHInterface->phid << 24;
            sess = arts_session_init(l_callid);
        }
        sess->transport_type = qtssRTPTransportTypeMPEG2;
        

        Assert(sess != NULL);
        QTSS_RTSPHeaderObject theHeader = inParams->inRTSPHeaders;
        QTSS_RTSPSessionObject theRTSPSession = inParams->inRTSPSession;

        memset(&callparams, 0, sizeof(callparams));
        callparams.callid = l_callid;
        callparams.listenport = sARTSPHInterface->listenport; 

        sess->RTSP_Session_Type = theSessionType;
	    LogRequest(DEBUG_ARTS_MODULE, l_callid, "session Type = %d", sess->RTSP_Session_Type);

        err = QTSS_GetValuePtr(theRequest, qtssRTSPReqAbsoluteURL, 0, (void **)&theRequestAttributes, &attributeLen);

        if(err == QTSS_NoErr)
            strncpy(callparams.requestURI, theRequestAttributes, attributeLen);

        err = QTSS_GetValuePtr(theRequest, qtssRTSPReqQueryString, 0, (void **)&theRequestAttributes, &attributeLen);

        if(err == QTSS_NoErr)
            strncpy(callparams.queryString, theRequestAttributes, attributeLen);

        if(isMP2TSFlag)
        {
            strcat(callparams.queryString,"&mux=mp2ts");
            sess->transport_type = qtssRTPTransportTypeMPEG2;
        }

        err = QTSS_GetValuePtr(theRTSPSession, qtssRTSPSesRemoteAddrStr, 0, (void **)&theRequestAttributes, &attributeLen);

        if(err == QTSS_NoErr)
            strncpy(callparams.clientIP, theRequestAttributes, attributeLen);

        err = QTSS_GetValuePtr(theClientSession, qtssCliSesFirstUserAgent, 0, (void **)&theRequestAttributes, &attributeLen);

        if(err == QTSS_NoErr)
            strncpy(callparams.userAgent, theRequestAttributes, attributeLen);

        err = QTSS_GetValuePtr(sServer, qtssSvrServerName, 0, (void **)&theRequestAttributes, &attributeLen);

        if(err == QTSS_NoErr)
            strncpy(callparams.serverName, theRequestAttributes, attributeLen);

        err = QTSS_GetValuePtr(theRTSPSession, qtssRTSPSesLocalAddrStr, 0, (void **)&theRequestAttributes, &attributeLen);

        if(err == QTSS_NoErr)
            strncpy(callparams.serverHost, theRequestAttributes, attributeLen);

        UInt16 localPort=0;
        attributeLen = sizeof(localPort);
        err = QTSS_GetValue(theRTSPSession, qtssRTSPSesLocalPort, 0, (void *)&localPort, &attributeLen);

        if(err == QTSS_NoErr)
            sprintf(callparams.serverPort, "%d", localPort);

        strcpy(callparams.serverProtocol, "RTSP 1.0");

        err = QTSS_GetValuePtr(theHeader, qtssBandwidthHeader, 0, (void**)&theRequestAttributes, &attributeLen);

        if(err == QTSS_NoErr)
            strncpy(callparams.Bandwidth, theRequestAttributes, attributeLen);

		//added by lijie, 2010.09.30	  
		err = QTSS_SetValue(theRTSPSession, sARTSRTSPSessionAttr, 0, (void *)&l_callid, sizeof(UInt32));	  
		Assert(err == QTSS_NoErr);
	    //jieli
        
        err = QTSS_SetValue(theClientSession, sARTSSessionAttr, 0, (void *)&l_callid, sizeof(UInt32));
        Assert(err == QTSS_NoErr);
		
        sess->remote_con = theClientSession;
        sess->RTSPRequest = theRequest;

        if(arts_send_conreq(sARTSPHInterface->controlsock->fd, &callparams) == -1)
        {
			if( sess->RTSP_Session_Type == qtssRTSPSession)
                QTSSModuleUtils::SendErrorResponseWithMessage(inParams->inRTSPRequest, qtssServerUnavailable, 0);
			
			if( sess->RTSP_Session_Type == qtssRTSPHTTPSession)
				QTSSModuleUtils::SendHTTPErrorResponse(inParams->inRTSPRequest,qtssServerUnavailable,true, NULL);

			OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
            arts_session_free(sess, 1);
	        return QTSS_RequestFailed;
        }
        ARTS_RequestEvent((Task **)&sess->task_ptr);
        return QTSS_NoErr;
    }

    if(sess->head.state == ARTS_CALL_STATE_DESTROY_NOW)
    {
        if( sess->RTSP_Session_Type == qtssRTSPSession)
        {
        
            QTSS_RTSPStatusCode  sCode = RTSPProtocol::GetQTSS_RTSPStatusCode(sess->ReleaseStatusCode);
            if(sCode != 0 )
                QTSSModuleUtils::SendErrorResponseWithMessage(inParams->inRTSPRequest,sCode , 0);
            else
                QTSSModuleUtils::SendErrorResponseWithMessage(inParams->inRTSPRequest,qtssServerUnavailable , 0);
        
        }
        
            //QTSSModuleUtils::SendErrorResponseWithMessage(inParams->inRTSPRequest, qtssServerUnavailable, 0);
    
        if( sess->RTSP_Session_Type == qtssRTSPHTTPSession)
            QTSSModuleUtils::SendHTTPErrorResponse(inParams->inRTSPRequest,qtssServerUnavailable,true, NULL);
    
        OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
        arts_session_free(sess,1);
        return QTSS_RequestFailed;
    }

    
   if(isMP2TSFlag)
   {
          
            sess->transport_type = qtssRTPTransportTypeMPEG2;
   
   }

    LogRequest(DEBUG_ARTS_MODULE, l_callid, "generating sdp");
    //changes reqd for thomson/stb where an sdp needs to be sent back as an response to setup
    iovec theDescribeVec[3] = { {0 }};
    ResizeableStringFormatter editedSDP(NULL,0);
    
    UInt32 sessLen=0;
    UInt32 mediaLen =0;
   

    QTSS_Error theErr = QTSS_NoErr;
    UInt32 callid, theLen = sizeof(callid);
    theErr = QTSS_GetValue(inParams->inClientSession, sARTSSessionAttr, 0, &callid, &theLen);
    Assert(theErr == QTSS_NoErr);
    sess = NULL;
    {
        OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
        sess = arts_session_find(callid);
    	if(!sess) return QTSS_NoErr;
    }

    //unless there is a digit at the end of this path (representing trackID), don't
    //even bother with the request
    char* theDigitStr = NULL;
    (void)QTSS_GetValueAsString(inParams->inRTSPRequest, qtssRTSPReqFileDigit, 0, &theDigitStr);
    QTSSCharArrayDeleter theDigitStrDeleter(theDigitStr);
    UInt32 theTrackID = 1;

    QTSS_RTPPayloadType thePayloadType = qtssUnknownPayloadType;

    //Create a new RTP stream
    QTSS_RTPStreamObject newStream = NULL;
    qtss_printf("--begin add stream");
    theErr = QTSS_AddRTPStream(inParams->inClientSession, inParams->inRTSPRequest, &newStream, 1);
    qtss_printf("--end add stream,err:%d\n",theErr);
    if (theErr != QTSS_NoErr)
        return theErr;

    thePayloadType = qtssVideoPayloadType;
    sess->video_str = newStream;
    theErr = QTSS_SetValue(newStream, qtssRTPStrSSRC, 0, &sess->rtp_video_SSRC, sizeof(sess->rtp_video_SSRC));
      
    Assert(theErr == QTSS_NoErr);

    if(sEnableDiffServ)
        theErr = QTSS_Enable_DiffServ(newStream, sARTSDSCP);  
     
    Assert(theErr == QTSS_NoErr);


    theErr = QTSS_SetValue(newStream, qtssRTPStrPayloadType, 0, &thePayloadType, sizeof(thePayloadType));
    Assert(theErr == QTSS_NoErr);

    theErr = QTSS_SetValue(newStream, qtssRTPStrTrackID, 0, &theTrackID, sizeof(theTrackID));
    Assert(theErr == QTSS_NoErr);
    char *theFullRequest = NULL;
    err = QTSS_GetValueAsString(theRequest, qtssRTSPReqFullRequest, 0, &theFullRequest);

    if (err != QTSS_NoErr)
    {
        return QTSS_NoErr;
    }
    if(strstr(theFullRequest,"x-playNow")) //If Request contains x-playNow call DoPlay from here only
        DoPlay(inParams, 0);


    if(strstr(theFullRequest,"application/sdp"))
    {
        StrPtrLen contentTypeHeader("application/sdp");
        (void)QTSS_AppendRTSPHeader(inParams->inRTSPRequest, qtssContentTypeHeader,
                                            contentTypeHeader.Ptr, contentTypeHeader.Len);
    }
   
   /* 
    char *cacheCStr = "no-cache";
    StrPtrLen cachStr(cacheCStr,strlen(cacheCStr));
    (void)QTSS_AppendRTSPHeader(inParams->inRTSPRequest, qtssCacheControlHeader,
                                cachStr.Ptr, cachStr.Len);
     
    */
    QTSS_SendStandardRTSPResponse(inParams->inRTSPRequest, newStream, 0);
    arts_ph_delete_keyvalues(sess->keyValuePairs, sess->numKeyValuePairs);
    sess->keyValuePairs = NULL;
    sess->numKeyValuePairs = 0;
    
    LogRequest(INFO_ARTS_MODULE, callid, "Exiting ");

    return  QTSS_NoErr; 
}
//init some date when start play
void init_thread(arts_session *sess)
{
    if(sess == NULL)
        return ;
    OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);   
    LogRequest(INFO_ARTS_MODULE, sess->callid,"clean buffer");
	clear_buffer(sess); 
	custom_struct_t * custom_struct = (custom_struct_t *)sess->darwin_custom_struct;
	custom_struct->seek_start_dts =0; 
	custom_struct->duration = 0;	
	custom_struct->buf_duration = -1; 
	sess->rtp_packet_buffer = NULL;
	sess->rtp_packet_buffer_len = 0 ;
	//sess->first_packet.pkt_len = 0; 
	set_need_idel_time(0,sess);   
	
	if(custom_struct->isIpqam == true && custom_struct->tsctx != NULL)
	{
	    MpegTSContext *ts=( MpegTSContext *)(custom_struct->tsctx);
	    ts->pcr_pkts_count =0;
	    ts->sdt_pkts_count =0;
	    ts->bat_pkts_count =0;
	    ts->sdt_bat_count =0;
	    ts->nit_pkts_count =0;
	}  
    
    
    
}

int64_t  append_range_header(arts_session* sess,QTSS_StandardRTSP_Params* inParams)
{
     if(sess == NULL)
        return 0;
        
     custom_struct_t *custom_struct = (custom_struct_t *)sess->darwin_custom_struct;
     Assert(custom_struct != NULL);
     double range_npt_start =0.0;
     static char *l_sdpName = "Range";
     char rangeCstr[256] ={'\0'}; 
     StrPtrLen rangeStr;  
     int l_Index = 0;
     for ( l_Index = 0 ; l_Index < sess->numKeyValuePairs; l_Index++)
     {
           if(sess->keyValuePairs[l_Index].name && 
                        sess->keyValuePairs[l_Index].value)
           {
                if(strcmp(l_sdpName,sess->keyValuePairs[l_Index].name) == 0) 
                {                        
                     char range[128]={'\0'};
                     memcpy(range,sess->keyValuePairs[l_Index].value,strlen(sess->keyValuePairs[l_Index].value));
                     LogRequest(INFO_ARTS_MODULE,sess->callid,"range:%s",range);
                     range_npt_start= atoi(range) /1000.0;   
                     
                     custom_struct->play_responsed=1;                                      
                }
           }
     }
        
     double sdp_len = sess->total_content_length;
     char rangeHeader[128]={'\0'}; 
     int64_t pts =-1;  
     if(l_Index >0 )
     {
         if(sdp_len >0 && custom_struct->supportPTS == true)                          
            qtss_snprintf(rangeHeader,sizeof(rangeHeader) -1, "npt=%.6f-%.6f",range_npt_start,sdp_len) ;
         else
             qtss_snprintf(rangeHeader,sizeof(rangeHeader) -1, "npt=%.6f-",range_npt_start) ;      
         StrPtrLen rangeHeaderPtr(rangeHeader);
         (void)QTSS_AppendRTSPHeader(inParams->inRTSPRequest, qtssRangeHeader,
                                    rangeHeaderPtr.Ptr, rangeHeaderPtr.Len);   
         //pts = getLastPts(sess->rtp_packet_buffer,custom_struct);                           
                                   
    }
    else
    {    if(custom_struct->supportPTS == true)
        {
         memset(rangeHeader,0,sizeof(rangeHeader))   ;     
         if(sdp_len >0)               
            qtss_snprintf(rangeHeader,sizeof(rangeHeader) -1, "npt=0.000000-%.6f",sdp_len) ;
         else
            qtss_snprintf(rangeHeader,sizeof(rangeHeader) -1, "npt=0.000000-") ;
                
         StrPtrLen rangeHeaderPtr(rangeHeader);
         (void)QTSS_AppendRTSPHeader(inParams->inRTSPRequest, qtssRangeHeader,
                                    rangeHeaderPtr.Ptr, rangeHeaderPtr.Len); 
          pts =custom_struct->first_pts ;
          if(pts <0)
            return pts;
       }
                                           
     } 
     
     
     if(custom_struct->supportPTS==true )
     {
        pts =custom_struct->first_pts*100/9;
        //pts = pts/90;
        LogRequest(INFO_ARTS_MODULE,sess->callid,"pts:%u,custom_struct->first_pts:%u",pts,custom_struct->first_pts);
        /*
        if(pts <=0)
        {
            pts = (range_npt_start) *1000;
            LogRequest(INFO_ARTS_MODULE,sess->callid,"pts:%d",pts);
        }*/
        if(pts >=0)
        {
           
            memset(rangeHeader,0,sizeof(rangeHeader)) ; 
            qtss_snprintf(rangeHeader,sizeof(rangeHeader) -1, "%u",pts) ;
            StrPtrLen rangeHeaderPtr1(rangeHeader);
            (void)QTSS_AppendRTSPHeader(inParams->inRTSPRequest, qtssXTSInfoHeader,
                                    rangeHeaderPtr1.Ptr, rangeHeaderPtr1.Len);  
         }
     }                  
    
    return pts;
}
void init_play(arts_session * sess,UInt32 callid,QTSS_StandardRTSP_Params* inParams)
{
  
    if(callid <=0)
        return;
        
  
    if(sess == NULL)
        return;
    if(sess->darwin_custom_struct!=NULL)
    {
        custom_struct_t * custom_struct = (custom_struct_t *)sess->darwin_custom_struct;
        custom_struct->need_send_packet_num =0;              
           
        custom_struct->last_pts =0;     
        custom_struct->play_responsed = 0;        
        
        if(custom_struct->receive_pkts_thread == NULL)
        {           
           ARTS_Get_Packet * sARTSGetPacket = NEW ARTS_Get_Packet();                                 
           init_thread(sess);    
           sARTSGetPacket->callid = callid;
	       sARTSGetPacket->inParams = inParams;	
	       custom_struct->receive_pkts_thread =  sARTSGetPacket;   
	            
         }
             
    }
}



QTSS_Error send_play_request(UInt32 callid)
{
    if(callid <0)
     return QTSS_NoErr;
     
   arts_session  * sess = arts_session_find(callid);
   custom_struct_t * custom_struct = (custom_struct_t*)sess->darwin_custom_struct;
   LogRequest(DEBUG_ARTS_MODULE, sess->callid,"sess->head.state:%x",sess->head.state);
  if(sess == NULL || custom_struct == NULL)
    return QTSS_NoErr; 
  if ( !(sess->head.state & ARTS_CALL_STATE_PLAY_CMD_SENT) && strlen(custom_struct->rangeHeader_global) >0 ) 
  {
      arts_rtsp_additional_headers rtspHeader;
      memset(&rtspHeader, 0, sizeof(rtspHeader));
	
      rtspHeader.callid = callid;
      strcpy(rtspHeader.method,"Play");
      
      int numKeyValues = 0;
	  int numMoreHeaders = 1; //only Range header	now
	
	  rtspHeader.keyValuePairs = arts_ph_create_keyvalues(numMoreHeaders);
	  arts_ph_calloc_keyvalue(rtspHeader.keyValuePairs, numKeyValues, "Range", custom_struct->rangeHeader_global );
      numKeyValues++;
     
      rtspHeader.numKeyValuePairs = numKeyValues;
	  
	
	  arts_send_additional_rtsp_Headers(sARTSPHInterface->controlsock->fd, &rtspHeader); //send rtsp headers to controller
	
	  arts_ph_delete_keyvalues(rtspHeader.keyValuePairs, numMoreHeaders);
	  LogRequest(INFO_ARTS_MODULE, callid,"posted play request,range:%s\n",custom_struct->rangeHeader_global);
	  sess->head.state |= ARTS_CALL_STATE_PLAY_CMD_SENT ;
	  
	  memset(custom_struct->rangeHeader_global,0,sizeof(custom_struct->rangeHeader_global))	;
	  
	  custom_struct->seek = true;
	  custom_struct->seek_start_dts = 0;  
     
   }
   return 0;
}


static void getCseq(arts_session * sess,QTSS_StandardRTSP_Params* inParams)
{
     if(sess == NULL || inParams == NULL)
        return ;
    char *theRequestAttributes=NULL;
    UInt32 attributeLen = 0,callid=sess->callid,err=0;
    QTSS_RTSPHeaderObject theHeader = inParams->inRTSPHeaders;
    custom_struct_t * custom_stru =(custom_struct_t *) sess->darwin_custom_struct;
	Assert(custom_stru != NULL);
	
	err = QTSS_GetValuePtr(theHeader, qtssCSeqHeader, 0, (void **)&theRequestAttributes, &attributeLen);
	if(err == QTSS_NoErr && attributeLen >0)
	{
	    custom_stru->cseq = atoi(theRequestAttributes); 
	    LogRequest(DEBUG_ARTS_MODULE, callid,"cur cseq:%d",custom_stru->cseq);	                
	}	
}

static void SetOtherChannel(arts_session * sess,QTSS_StandardRTSP_Params* inParams)
{
    if(sess == NULL || inParams == NULL)
        return ;
    char *theRequestAttributes=NULL;
    
    
    //QTSS_RTSPRequestObject theRequest = inParams->inRTSPRequest;
    
    UInt32 attributeLen = 0,callid=sess->callid,err=0;
   
	custom_struct_t * custom_stru =(custom_struct_t *) sess->darwin_custom_struct;
	//Assert(custom_stru != NULL);
	if(custom_stru == NULL)
	{
	    abort();
	}
	
	
	if(custom_stru->OwnRTSPSessionObj != NULL)
	    return ;
	RTSPRequestInterface * theRTSPRequest = (RTSPRequestInterface*)inParams->inRTSPRequest;
	RTSPSession *theRTSPSession = (RTSPSession *)inParams->inRTSPSession;
	custom_stru->OwnRTSPSessionObj = theRTSPSession;
	//custom_stru->isIpqam = theRTSPRequest->GetIsIpqam();
	//gRequest(DEBUG_ARTS_MODULE, callid,"isIpqam:%d",custom_stru->isIpqam);
	getCseq(sess,inParams);
	QTSS_RTSPRequestObject theRequest = inParams->inRTSPRequest;
	err = QTSS_GetValuePtr(theRequest, qtssRTSPReqAbsoluteURL, 0, (void **)&theRequestAttributes, &attributeLen);

    if(err == QTSS_NoErr)
        strncpy(custom_stru->uri, theRequestAttributes, attributeLen);
	
    if(sess->transport_type == qtssRTPTransportTypeMPEG2 && sARTSPHInterface->co_socket_list!=NULL && custom_stru->RTPSessionObj == NULL)
	{
	   //ogRequest(DEBUG_ARTS_MODULE, callid,"--ENtry mp2t");
	    
	    RTPSessionInterface * theRTPSession = (RTPSessionInterface *)inParams->inClientSession;
	    
	    
	    StrPtrLen* sessionIDStr= theRTPSession->GetValue(qtssCliSesRTSPSessionID);	    
	    co_socket_t *p = sARTSPHInterface->co_socket_list;  
	    
	    
	     while(p&&p->sessionID[0]!='\0')
	     {
	           char *sessIDCStr = sessionIDStr->GetAsCString();
	           if(strncmp(sessIDCStr,p->sessionID,strlen(p->sessionID)) == 0 && p->used == false)
	           {	                 
	           
	                LogRequest(DEBUG_ARTS_MODULE, callid,"find rtspsessionObj");       
	                theRTSPSession->GetOutputStream()->SetDataSocket(p->sock);
	                
                    bool flag = theRTSPSession->GetSupportOtherChannel();
                    LogRequest(DEBUG_ARTS_MODULE, callid,"set supportOtherChannel:%d",flag);
	                
	                
	                custom_stru->RTSPSessionObj= p->rtspSessObj;
	                custom_stru->RTPSessionObj = p->rtpSessObj;
	                     
                     err = QTSS_GetValuePtr(theRequest, qtssRTSPReqQueryString, 0, (void **)&theRequestAttributes, &attributeLen);
                     if(err == QTSS_NoErr)
                     {
                       strncpy(custom_stru->uri+strlen(custom_stru->uri),"?",1), 
                        strncpy(custom_stru->uri+strlen(custom_stru->uri), theRequestAttributes, attributeLen);
                     }
	                                          
	                strcpy(custom_stru->sessionID,sessIDCStr);
	                            
	                custom_stru->supportOtherChannel= true;
	                p->used = true;
	                LogRequest(DEBUG_ARTS_MODULE, callid,"set socket of outputstream");
	                break;
	            }	            
	            p=(co_socket_t *)p->next;
	     }	    
	}
	
	if(custom_stru->RTPSessionObj != NULL)
	{
	    SInt64 timeoutInMs = 5*3600*1000;  
	    RTPSessionInterface * theRTPsession = (RTPSessionInterface *)custom_stru->RTPSessionObj;         
        //custom_stru->RTPSessionObj->SetTimeOuts(timeoutInMs);
        theRTPsession->SetTimeOuts(timeoutInMs);
	}
}


static void config_other_channel(arts_session * sess,StrPtrLen * sessionIDStr,RTSPSessionInterface *theRTSPSession)
{
    Assert(sess!= NULL);
    Assert(sessionIDStr!= NULL);
    Assert(theRTSPSession != NULL);
    co_socket_t *p = sARTSPHInterface->co_socket_list;
       
    while(p&&p->sessionID[0]!='\0')
    {
        char *sessIDCStr = sessionIDStr->GetAsCString();
        if(strncmp(sessIDCStr,p->sessionID,strlen(p->sessionID)) == 0 && p->used == false)
        {	
	               
            LogRequest(DEBUG_ARTS_MODULE, sess->callid,"find rtspsessionObj");       
            theRTSPSession->GetOutputStream()->SetDataSocket(p->sock);
	                
            theRTSPSession->SetSupportOtherChannel();
            bool flag = theRTSPSession->GetSupportOtherChannel();
            LogRequest(DEBUG_ARTS_MODULE, sess->callid,"set supportOtherChannel:%d",flag);
	                
            if(sess->darwin_custom_struct == NULL)
            {
                LogRequest(DEBUG_ARTS_MODULE, sess->callid,"sess->darwin_custom_struct == NULL:2647");
                sess->darwin_custom_struct = (custom_struct_t *)malloc(sizeof(custom_struct_t ));
                memset(sess->darwin_custom_struct,0,sizeof(custom_struct_t));
            }
            custom_struct_t * custom_stru =(custom_struct_t *) sess->darwin_custom_struct;
            custom_stru->RTSPSessionObj= p->rtspSessObj;
            custom_stru->RTPSessionObj = p->rtpSessObj;
	              
            RTPSession * otherRtpSession = (RTPSession *) custom_stru-> RTPSessionObj;
            SInt64 timeoutInMs = 5*3600*1000;
           
            otherRtpSession->SetTimeOuts(timeoutInMs);
            
            custom_stru->supportOtherChannel= true;
            p->used = true;
            LogRequest(DEBUG_ARTS_MODULE, sess->callid,"set socket of outputstream");
            break;
        }	            
        p=(co_socket_t *)p->next;
    }	    

}
int sock_init()
{
    int fd = socket(AF_INET, SOCK_DGRAM, 0);
    if(fd < 0) {
	    perror("socket(): error ");	 
	    abort();  
    } 
    
    return fd;
}

static int replay(arts_session * sess,QTSS_StandardRTSP_Params* inParams)
{
  
    if(sess == NULL || sess->darwin_custom_struct == NULL)
    return 0;
    custom_struct_t *custom_stru = (custom_struct_t *)sess->darwin_custom_struct;
    double sdp_len = sess->total_content_length;
    int64_t pts = getLastPts(sess->rtp_packet_buffer,custom_stru) - custom_stru->first_keyframe_pts;
    if(pts>=0)
    {                        
        //double ptsInS = (pts-custom_stru->first_pts)/90000.0;
        double ptsInS = pts /90000.0;
        // ptsInS -= (ptsInS >5)? 5:0;
        if(ptsInS <0)
          ptsInS =0;
        
        char rangeHeader[128]={'\0'};          
        if(sdp_len >0 )        
            qtss_snprintf(rangeHeader,sizeof(rangeHeader) -1, "npt=%.6f-%.6f",ptsInS,sdp_len);
        else
            qtss_snprintf(rangeHeader,sizeof(rangeHeader) -1, "npt=%.6f-",ptsInS);
        LogRequest(DEBUG_ARTS_MODULE, sess->callid,"range-pts:%s,cur_pts:%u,first_pts:%d,sdp_len:%f,pts:%.6f",rangeHeader,pts,custom_stru->first_pts,sdp_len,pts);
        StrPtrLen rangeHeaderPtr(rangeHeader);
        (void)QTSS_AppendRTSPHeader(inParams->inRTSPRequest, qtssRangeHeader,
                                                            rangeHeaderPtr.Ptr, rangeHeaderPtr.Len); 
                                            
        memset(rangeHeader,0,sizeof(rangeHeader));
        qtss_snprintf(rangeHeader,sizeof(rangeHeader) -1, "%u",pts*100/9);  
        StrPtrLen rangeHeaderPtr1(rangeHeader);                                 
        (void)QTSS_AppendRTSPHeader(inParams->inRTSPRequest, qtssXTSInfoHeader,
                                    rangeHeaderPtr1.Ptr, rangeHeaderPtr1.Len); 
                     
     }
     return 0;
}

#if 1
/* new DoPlay logic */
QTSS_Error DoPlay(QTSS_StandardRTSP_Params* inParams, bool sendResponseFlag)
{
    QTSS_Error err = QTSS_NoErr;
    char *theRequestAttributes=NULL;
    UInt32 callid, attributeLen = 0,theLen = sizeof(callid);
    QTSS_RTSPHeaderObject theHeader;
    err = QTSS_GetValue(inParams->inClientSession, sARTSSessionAttr, 0, &callid, &theLen);
    Assert(err == QTSS_NoErr);
	arts_session *sess = NULL;
	{
    	OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
	    sess = arts_session_find(callid);
    	if(!sess) return QTSS_NoErr;
	}
    LogRequest(INFO_ARTS_MODULE, callid, "Entering Play");
	qtss_printf("Entering Play, state:0x%x \n", sess->head.state );
	
	
	int seek_flag =0;


	if( sess->head.state == ARTS_CALL_STATE_DESTROY_NOW )
	{
		if( sess->RTSP_Session_Type == qtssRTSPSession)
        {

            QTSS_RTSPStatusCode  sCode = RTSPProtocol::GetQTSS_RTSPStatusCode(sess->ReleaseStatusCode);
            if(sCode != 0 )
                QTSSModuleUtils::SendErrorResponseWithMessage(inParams->inRTSPRequest,sCode , 0);
            else
                QTSSModuleUtils::SendErrorResponseWithMessage(inParams->inRTSPRequest,qtssServerUnavailable , 0);

        }    
		
		if( sess->RTSP_Session_Type == qtssRTSPHTTPSession)
			QTSSModuleUtils::SendHTTPErrorResponse(inParams->inRTSPRequest,qtssClientNotFound,true, NULL);
	    //qtss_printf("DoPlay QTSS_Teardown\n");
		(void)QTSS_Teardown(inParams->inClientSession);

		return QTSS_RequestFailed;
	}
    
   
    if(! (sess->head.state & ARTS_CALL_STATE_CONNECTED))
    {
        LogRequest(INFO_ARTS_MODULE, callid, "ARTS_CALL_STATE_NOT_CONNECTED");

        ARTS_RequestEvent((Task **)&sess->task_ptr);

        LogRequest(INFO_ARTS_MODULE, callid, "Wait for Request Event");
        qtss_printf("Wait for Request Event");
        return QTSS_NoErr;
    }
    
    
    SetOtherChannel(sess,inParams);
    
    init_play(sess,callid,inParams);  
    
    
	LogRequest(INFO_ARTS_MODULE, callid,"sess->head.state:%d",sess->head.state);
    if (! ( sess->head.state & ARTS_CALL_STATE_READ_CON_RESPONSE ) ) 
	{
		if ( !(sess->head.state & ARTS_CALL_STATE_PLAY_CMD_SENT) ) 
	    {
	        theHeader = inParams->inRTSPHeaders; 
	        arts_rtsp_additional_headers rtspHeader;
            memset(&rtspHeader, 0, sizeof(rtspHeader));
	
            rtspHeader.callid = callid;
            strcpy(rtspHeader.method,"Play");
    
            err = QTSS_GetValuePtr(theHeader, qtss3GPPLinkCharHeader, 0,(void **)&theRequestAttributes,&attributeLen);
	
            if(err == QTSS_NoErr)
            {
                strncpy(rtspHeader._3gppLinkChar,theRequestAttributes,attributeLen);
                rtspHeader._3gppLinkChar[attributeLen]='\0';
            }    
	
            err = QTSS_GetValuePtr(theHeader, qtss3GPPAdaptationHeader, 0,(void **)&theRequestAttributes,&attributeLen);
	
            if(err == QTSS_NoErr)
            {
                strncpy(rtspHeader._3gppAdaptationHeader,theRequestAttributes,attributeLen);
                rtspHeader._3gppAdaptationHeader[attributeLen] = '\0';
            }    
	
	        //LiJie modified on 2012.09.19
	        //add play range support, or rtsp seek support for ARTS
	        int numKeyValues = 0;
	        int numMoreHeaders = 1; //only Range header	now
	
	        rtspHeader.keyValuePairs = arts_ph_create_keyvalues(numMoreHeaders);
	
	        err = QTSS_GetValuePtr(theHeader, qtssRangeHeader, 0,(void **)&theRequestAttributes,&attributeLen);
	        custom_struct_t * custom_stru =(custom_struct_t *) sess->darwin_custom_struct;
	        if(attributeLen == 0)
	        {
	            if(custom_stru->supportPTS == true)
	            {
	                replay(sess,inParams);
	            }
                if (sess->transport_type == qtssRTPTransportTypeMPEG2){
                            ((RTSPRequestInterface*)(inParams->inRTSPRequest))->SetTransportType(qtssRTPTransportTypeMPEG2);
                        err = QTSS_SendStandardRTSPResponse(inParams->inRTSPRequest, inParams->inClientSession, 0);
                }else{
                        err = QTSS_SendStandardRTSPResponse(inParams->inRTSPRequest, inParams->inClientSession, qtssPlayRespWriteTrackInfo);
                } 
                    
                    //Ipqam has special send Packet method instead of sendPacket callback of rtpsession       
                if(custom_stru->isIpqam ==false)
                        err = QTSS_Play(inParams->inClientSession, inParams->inRTSPRequest, qtssPlayFlagsSendRTCP);
                    //else
                        // sARTSSendPktThread->beActived();
                        
                sess->mpeg2_start_time = QTSS_Milliseconds();
                LogRequest(INFO_ARTS_MODULE, callid,"send response to client due to no range,sess->mpeg2_start_time:%"_64BITARG_"d",sess->mpeg2_start_time);
               
                Assert(err == QTSS_NoErr);  
                return QTSS_NoErr; 
	        }
	        if(err == QTSS_NoErr)
            {
		        char sRangeHeader[256];
                strncpy(sRangeHeader,theRequestAttributes,attributeLen);                
                sRangeHeader[attributeLen] = '\0';        
	            		        
		        
		        StrPtrLen rangeHeader(sRangeHeader,strlen(sRangeHeader));
                StringParser  theRangeParser(&rangeHeader);               
                theRangeParser.GetThru(NULL, '=');//consume "npt="
                theRangeParser.ConsumeWhitespace();
                Float64 fStartTime = (Float64)theRangeParser.ConsumeNPT(); 
                
               
                LogRequest(INFO_ARTS_MODULE, callid,"rangeHeader:%s,receive_pkt_thread:%X:",rangeHeader.Ptr,custom_stru->receive_pkts_thread);            
                
                seek_flag = 1;
                 
                if( ((custom_stru->seek ==true && custom_stru->seek_start_dts <=0) ||strlen(custom_stru->rangeHeader_global)>0 )
                    && strcmp(rangeHeader.Ptr,"npt=-")!=0   )
                {                  
                     strncpy(custom_stru->rangeHeader_global,sRangeHeader,sizeof(custom_stru->rangeHeader_global));
                     LogRequest(INFO_ARTS_MODULE, callid,"queue this range play");
                     RTSPSessionInterface * theRTSPSess =(RTSPSessionInterface *) inParams->inRTSPSession;
                     theRTSPSess->GetOutputStream()->SetBytesWritten();
                     return QTSS_NoErr;    
                }
                 
                if( strcmp(rangeHeader.Ptr,"npt=-") == 0 || (custom_stru != NULL && custom_stru->receive_pkts_thread == NULL)  )
                {
                    if(strcmp(rangeHeader.Ptr,"npt=-") == 0)
                    {
                        sess->mpeg2_start_time = QTSS_Milliseconds();                        
                    }
                    replay(sess,inParams);
                    if (sess->transport_type == qtssRTPTransportTypeMPEG2){
                            ((RTSPRequestInterface*)(inParams->inRTSPRequest))->SetTransportType(qtssRTPTransportTypeMPEG2);
                        err = QTSS_SendStandardRTSPResponse(inParams->inRTSPRequest, inParams->inClientSession, 0);
                    }else{
                        err = QTSS_SendStandardRTSPResponse(inParams->inRTSPRequest, inParams->inClientSession, qtssPlayRespWriteTrackInfo);
                    } 
                    
                    //Ipqam has special send Packet method instead of sendPacket callback of rtpsession       
                    if(custom_stru->isIpqam ==false)
                        err = QTSS_Play(inParams->inClientSession, inParams->inRTSPRequest, qtssPlayFlagsSendRTCP);
                    //else
                        // sARTSSendPktThread->beActived();
                    LogRequest(INFO_ARTS_MODULE, callid,"send response to client due to rangeHeader=npt,sess->mpeg2_start_time:%"_64BITARG_"d",sess->mpeg2_start_time);
                    Assert(err == QTSS_NoErr);  
                    return QTSS_NoErr; 
                }     
                    
               /*
               if(strcmp(rangeHeader.Ptr,"npt=-") == 0  )
               {
                    memset(sRangeHeader,0,sizeof(sRangeHeader));
                    
                    int64_t pts = getLastPts(sess->rtp_packet_buffer,custom_stru);
                    if(pts>=0)
                    {                        
                        int64_t  ptsInS = (pts-custom_stru->first_pts)/90000;
                        sprintf(sRangeHeader,"npt=%d-",ptsInS);
                        LogRequest(INFO_ARTS_MODULE, callid,"pause-play:range-Header:%s",sRangeHeader);
                    }
                                   
               }  */  
                    
                            
                arts_ph_calloc_keyvalue(rtspHeader.keyValuePairs, numKeyValues, "Range", sRangeHeader);
                if(fStartTime >= 0.0)
                {    
                    init_thread(sess); 
                                 
                    if(custom_stru != NULL)
                    {
                        custom_stru->seek = true;                                              
                        sess->first_packet.pkt_len =0;
                        custom_stru ->last_recv_PCR = 0;
                        LogRequest(DEBUG_ARTS_MODULE, callid,"custom_stru ->last_recv_PCR = 0;");                      
                        custom_stru->full_send = false;  
                        custom_stru->buf_duration =0;  
                        custom_stru->waite_time =0 ;    
                        custom_stru->pause_start_time =0; 
                        custom_stru->first_pts = -1;     
                    }
                }else
                    custom_stru->seek_start  = false;          
		        
		        
		       
		        numKeyValues++;
            }  		
	
	        rtspHeader.numKeyValuePairs = numKeyValues;
	  
	
	        arts_send_additional_rtsp_Headers(sARTSPHInterface->controlsock->fd, &rtspHeader); //send rtsp headers to controller
	
	        arts_ph_delete_keyvalues(rtspHeader.keyValuePairs, numMoreHeaders);
	        LogRequest(INFO_ARTS_MODULE, callid,"posted play request");
	        sess->head.state |= ARTS_CALL_STATE_PLAY_CMD_SENT ;
	        
		}
	   // If we are doing RTP-Meta-Info stuff, we might be asked to get called again here.
	   // This is simply because seeking might be a long operation and we don't want to
	   // monopolize the CPU, but there is no other reason to wait, so just set a timeout of 0
	   custom_struct_t * custom_stru =(custom_struct_t *) sess->darwin_custom_struct;
	   if(custom_stru != NULL)
	   {
	        if(custom_stru->waite_time >5000)
	        {
	            LogRequest(INFO_ARTS_MODULE, callid,"after play send cost 5s,we will TearDown");
	            return QTSS_Teardown(inParams->inClientSession);                
	        }
            custom_stru->waite_time += 200;
       }
	   err = QTSS_SetIdleTimer(200);	   
	   LogRequest(INFO_ARTS_MODULE, callid,"QTSS_SetIdleTimer(200)");
	   Assert(err == QTSS_NoErr);
	   //GetStreamPackets(sess, false);  // receive some useless packets to unlock the sender, ugly!!
	   return err;	   
	}
	
	
#if DO_BLOCK_READ
    if ( ( (sess->rtp_media_type & ARTS_VIDEO_SESSION ) ) || 
			( (sess->rtp_media_type & ARTS_AUDIO_SESSION ) ) )
#else
    if ( ( (sess->rtp_video_seqnum == 0xffff) && (sess->rtp_media_type & ARTS_VIDEO_SESSION ) ) || 
			( (sess->rtp_audio_seqnum == 0xffff) && (sess->rtp_media_type & ARTS_AUDIO_SESSION ) ) )
#endif
    {
        
        err = GetStreamPackets(sess, false);
#if DO_BLOCK_READ
        if (err == QTSS_NoMoreData) {
            //
            // If we are doing RTP-Meta-Info stuff, we might be asked to get called again here.
            // This is simply because seeking might be a long operation and we don't want to
            // monopolize the CPU, but there is no other reason to wait, so just set a timeout of 0
            err = QTSS_SetIdleTimer(10);
            LogRequest (INFO_ARTS_MODULE, callid, "Sleeping till I get data");
            Assert(err == QTSS_NoErr);
            return err;
        }
        else if( err != QTSS_NoErr)

#else
        if( err != QTSS_NoErr   )
#endif
        {
			qtss_printf("return error response \n");
            QTSSModuleUtils::SendErrorResponse(inParams->inRTSPRequest, qtssSuccessNoContent, 0); 
            return QTSS_NoErr;
        }
    }

	if(sess->rtp_media_type & ARTS_VIDEO_SESSION)
	{
	    err = QTSS_SetValue(sess->video_str, qtssRTPStrFirstSeqNumber, 0, &sess->rtp_video_seqnum, sizeof(sess->rtp_video_seqnum));
    	Assert(err == QTSS_NoErr);

    	err = QTSS_SetValue(sess->video_str, qtssRTPStrFirstTimestamp, 0, &sess->rtp_video_timestamp, sizeof(sess->rtp_video_timestamp));
    	Assert(err == QTSS_NoErr);

	    LogRequest(INFO_ARTS_MODULE, callid, "video sequence no = %u time stamp = %u " ,sess->rtp_video_seqnum, sess->rtp_video_timestamp);
		
	}

	if(sess->rtp_media_type & ARTS_AUDIO_SESSION)
	{
    	err = QTSS_SetValue(sess->audio_str, qtssRTPStrFirstSeqNumber, 0, &sess->rtp_audio_seqnum, sizeof(sess->rtp_audio_seqnum));
    	Assert(err == QTSS_NoErr);

	    err = QTSS_SetValue(sess->audio_str, qtssRTPStrFirstTimestamp, 0, &sess->rtp_audio_timestamp, sizeof(sess->rtp_audio_timestamp));
    	Assert(err == QTSS_NoErr);

		LogRequest(INFO_ARTS_MODULE, callid, "audio sequence no = %u time stamp = %u " ,sess->rtp_audio_seqnum, sess->rtp_audio_timestamp);   
	}
	qtss_printf("After setting up, seqnum_v: %d,seqnum_a: %d, rtp_vt: %u, rtp_at: %u \n",sess->rtp_video_seqnum,    sess->rtp_audio_seqnum,
				sess->rtp_video_timestamp, sess->rtp_audio_timestamp );
				
       
    sess->head.state |= ARTS_CALL_STATE_PLAY;
    custom_struct_t * custom_struct = NULL;
    
    {
        //OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
        custom_struct= (custom_struct_t *)sess->darwin_custom_struct;   
   
        //gRequest(DEBUG_ARTS_MODULE, callid,"DoPlay isIpqam:%d",custom_struct->isIpqam);
        if(  (sess->head.state & ARTS_CALL_STATE_PLAY) &&  (custom_struct->adapter_unregister == true) && (custom_struct->buf_duration == -1) && custom_struct->play_idel == false )
	    {	    
	    
            fdevent_event_add(sARTSPHInterface->ev, sess->head.sock, FDEVENT_IN | FDEVENT_HUP);	
            LogRequest(INFO_ARTS_MODULE, callid,"event_add,fd:%d",sess->head.sock->fd);  		
            custom_struct->adapter_unregister = false;		
        }
    }
    
    	 
    if(sendResponseFlag)
    {
         
        if(append_range_header(sess,inParams)<0 )
        {
            QTSS_SetIdleTimer(100);	   
	        LogRequest(INFO_ARTS_MODULE, callid,"QTSS_SetIdleTimer(100)");
	        custom_struct->play_idel = true;
	        Assert(err == QTSS_NoErr);	   
	        return err;	  
        }
    
        custom_struct->play_idel = false;
        //err = QTSS_SendStandardRTSPResponse(inParams->inRTSPRequest, inParams->inClientSession, qtssPlayRespWriteTrackInfo);
        if (sess->transport_type == qtssRTPTransportTypeMPEG2){
            ((RTSPRequestInterface*)(inParams->inRTSPRequest))->SetTransportType(qtssRTPTransportTypeMPEG2);
            err = QTSS_SendStandardRTSPResponse(inParams->inRTSPRequest, inParams->inClientSession, 0);
        }else{
            err = QTSS_SendStandardRTSPResponse(inParams->inRTSPRequest, inParams->inClientSession, qtssPlayRespWriteTrackInfo);
        }
		sess->head.state &= ~ARTS_CALL_STATE_READ_CON_RESPONSE;
		//qtss_printf("after response Play, state:%x \n", sess->head.state );
        Assert(err == QTSS_NoErr);   
        
    }
    
   
    
    
   if(custom_struct->isIpqam ==false)
   {
        err = QTSS_Play(inParams->inClientSession, inParams->inRTSPRequest, qtssPlayFlagsSendRTCP);
        Assert(err == QTSS_NoErr);   
  
   } 
   else
   {
   
       if(custom_struct->sendEv == NULL)
       {
        OSMutexLocker registListMutex(&sARTSSendPktThread->regist_list_Mutex);
        sARTSSendPktThread->insert_regist_node(sess->callid);
        LogRequest(DEBUG_ARTS_MODULE, callid, "insert regist_node:%x", sARTSSendPktThread->regist_list);
      
           
        timeout_ev_t *curSendEv = (timeout_ev_t *)malloc(sizeof(timeout_ev_t));
        Assert(curSendEv != NULL);
        memset(curSendEv,0,sizeof(timeout_ev_t));
        curSendEv->sockfd = sock_init();
        curSendEv->callid =callid;
        custom_struct->sendEv = curSendEv;
        
        RTPSessionInterface * theRTPSession = (RTPSessionInterface *)inParams->inClientSession;
        
        SInt64 timeoutInMs = 5*3600*1000;           
        theRTPSession->SetTimeOuts(timeoutInMs);
        
        //sARTSSendPktThread->beActived();
        LogRequest(DEBUG_ARTS_MODULE, callid,"active ipqam send packets");  
      }      
      else
      {   
           timeout_ev_t *curSendEv = (timeout_ev_t *)custom_struct->sendEv;
           if(curSendEv->pause==true)
           {              
                curSendEv->pause=false;
           }           
      }
          
     
                  
   }
    sess->first_packet_send_time = QTSS_Milliseconds();
    sess->mpeg2_start_time = sess->first_packet_send_time;
    
    if(custom_struct!= NULL)
        custom_struct ->pkt_transformat = 0;
	sess->last_rtsp_bitrate_update_time = sess->first_packet_send_time;
	sess->head.state &= ~ARTS_CALL_STATE_PLAY_CMD_SENT;  // ready to receive new play requests
    
    
	//qtss_printf("first_packet_send_time = %"_64BITARG_"d" ,sess->first_packet_send_time);
	LogRequest(INFO_ARTS_MODULE, callid, "first_packet_send_time = %"_64BITARG_"d" ,sess->first_packet_send_time);
    LogRequest(INFO_ARTS_MODULE, callid, "Exiting " );

    return err;
}

#endif 



Bool8 IsDiscontinuityFlag(UInt8 *packetData, UInt32 remainPacketLength)
{
    while(remainPacketLength > 188)
    {
        if(!(*(packetData+3)& ADAPTATION_FLAG))
        {
            packetData += 188;
            remainPacketLength -= 188;
            continue; 
        }
        if(*(packetData+5)& DISCONTINUITY_FLAG)
        {
            return true;
        }
        else
        {
            packetData += 188;
            remainPacketLength -= 188;
            continue; 
        }
    }
    return false;
}


SInt64 GetMPEG2PCR(UInt8 *packetData, UInt32 *remainPacketLength)
{
    
        SInt64 PCR = -1;
        SInt64 PCR_base = 0;
        SInt64 PCR_ext = 0;

        if(*remainPacketLength < MIN_PACK_LEN_FOR_PCR || !(*(packetData+3)& ADAPTATION_FLAG))
            return PCR;
        int adp_len =packetData[4];
        if(adp_len <=0 )
        return PCR;
        
        if(*(packetData+5)& PCR_FLAG)
        {
            int i;
            for(i = 6; i < 10; i++)
            {
                PCR_base = PCR_base * 256 + *(packetData+i);
		//printf("PCR Base is %lld\n",PCR_base);
            }
            PCR_base *= 2;
            PCR_base = packetData[i] & 0x80 ? PCR_base + 1:PCR_base;
            PCR_ext = packetData[i++] & 0x7F;
            PCR_ext *= 2;
            PCR_ext = packetData[i] & 0x80 ? PCR_ext + 1:PCR_ext;
            PCR_ext *= 2;
            PCR_ext = packetData[i] & 0x40 ? PCR_ext + 1:PCR_ext;
            PCR = PCR_base * 300 + PCR_ext;
        }
        return PCR;
}



static  int64_t GetFrameDuration(arts_session *sess)
{
   rtp_packet_buffer_type  *p = (rtp_packet_buffer_type *)sess->rtp_packet_buffer;
   rtp_packet_buffer_type *nextone =NULL;
   if(sess == NULL)
    return 0;
    
   
   if ( p->next!=NULL)
   {
      nextone = (rtp_packet_buffer_type *)p->next;
      //LogRequest(DEBUG_ARTS_MODULE, 0,"the next time_stamp:%u,cur_timestamp:%u",nextone->timestamp,p->timestamp);
      return nextone->timestamp - p->timestamp;
   }
    else 
    {
        custom_struct_t *cur_struct = (custom_struct_t *)sess->darwin_custom_struct;
        if(cur_struct != NULL)
            return cur_struct->duration;
        else
          return 0;
    }
   return 0;
}

QTSS_Error SendMpeg2Packets(QTSS_RTPSendPackets_Params* inParams)
{   
    QTSS_Error theErr = QTSS_NoErr;
    UInt32 callid, theLen = sizeof(callid);	
	UInt32 theSendInterval = QTSServerInterface::GetServer()->GetPrefs()->GetSendIntervalInMsec();	
	
#if ! DO_BLOCK_READ
    SInt32 in = 0;  
#endif
    theErr = QTSS_GetValue(inParams->inClientSession, sARTSSessionAttr, 0, &callid, &theLen);
    Assert(theErr == QTSS_NoErr); 
    
    arts_session *sess = NULL;
    {
        //OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
        sess = arts_session_find(callid);
    }
     //LogRequest(DEBUG_ARTS_MODULE, callid,"sess:%x",sess);
    if(!sess) return QTSS_NoErr;    
    
    while(true)
    {
       QTSS_TimeVal curtime =0;    
        custom_struct_t * custom_struct = (custom_struct_t*)sess->darwin_custom_struct;   
        
send:             
         
        curtime = QTSS_Milliseconds();
        
         if(sess->mpeg2_start_time <=0){
            sess->mpeg2_start_time = curtime; 
            LogRequest(DEBUG_ARTS_MODULE, callid,"sess->mpeg2_start_time:%"_64BITARG_"d",sess->mpeg2_start_time);                            
         }
         
       LogRequest(DEBUG_ARTS_MODULE, callid,"sess->bufer_len:%d,sess->mpeg2_start_time:%"_64BITARG_"d,first_packet.pkt_len:%d",sess->rtp_packet_buffer_len,sess->mpeg2_start_time,sess->first_packet.pkt_len);
        if(sess->first_packet.pkt_len >0  && sess->first_packet.pkt_len % TS_PACKET_SIZE ==0 )
        {
            QTSS_PacketStruct thePacket;
            thePacket.packetData = sess->first_packet.pkt_buf;  
            
           
            int64_t pkt_transformat = custom_struct->pkt_transformat;
	        if(custom_struct == NULL)
	        {
	            LogRequest(DEBUG_ARTS_MODULE, callid,"custom_struct is null");
	            return QTSS_NoErr;
	        }                    
            custom_struct->send_idel_time = 0;         
          
         
             int64_t startDts = GetseekStartDts(sess);
             
             int64_t sendTime = 0;
          
            if(startDts >0 && pkt_transformat ==0)
            {
                sendTime = sess->mpeg2_start_time;
            }else
                sendTime =sess->mpeg2_start_time + pkt_transformat-startDts;  
            
                
           // LogRequest(DEBUG_ARTS_MODULE, callid,"sendTime:%d,pkt_transformat:%d",sendTime,pkt_transformat); 
            
            if(sendTime <=0)
                thePacket.packetTransmitTime = curtime;
            else
                thePacket.packetTransmitTime = sendTime;
          
             
            if((thePacket.packetTransmitTime -curtime > theSendInterval*10) )
            {
              
                inParams->outNextPacketTime = theSendInterval;
                 LogRequest(DEBUG_ARTS_MODULE, callid,"cur pkts transmittime:%"_64BITARG_"d,outNextPacketTime:%"_64BITARG_"d,need sleep 50 ms",thePacket.packetTransmitTime,inParams->outNextPacketTime);                 
                 set_need_idel_time(inParams->outNextPacketTime,sess);
                 return   QTSS_NoErr;
                             
            }                               
                 
            
            theErr = QTSS_Write(sess->video_str, &thePacket, sess->first_packet.pkt_len, NULL, qtssWriteFlagsIsMpeg2);                
            LogRequest(DEBUG_ARTS_MODULE, callid,"send,transmittime:%"_64BITARG_"d,theErr:%d,curTime:%"_64BITARG_"d,pkt_len:%d",
                thePacket.packetTransmitTime, theErr,curtime,sess->first_packet.pkt_len);
            
           
            if(theErr==QTSS_NoErr)
            {   
                if(custom_struct->supportOtherChannel == true)    
                {     
                    LogRequest(DEBUG_ARTS_MODULE, callid,"set channel Num");   
                    RTPStream *theRTPStream = (RTPStream *)sess->video_str;                    
                    UInt8 channel_num = theRTPStream->GetRTPChannelNum();
                    if(channel_num >=0)
                    {
                        channel_num += 1;
                        theRTPStream->SetRTPChannelNum(channel_num);
                    }
                }
               
                if(custom_struct ->ofd!= NULL)
                {
                   ::fwrite(sess->first_packet.pkt_buf,sizeof(char),sess->first_packet.pkt_len,custom_struct->ofd);            
                 }             
                
                sess->rtp_mpeg2_bytes_sent += sess->first_packet.pkt_len;
                sess->first_packet.pkt_len = 0;   
                
                
                inParams->outNextPacketTime = 0;
           }else  if(theErr==QTSS_WouldBlock)
		   {
		         
	             QTSS_TimeVal  CurrentTime = QTSS_Milliseconds();
                 QTSS_TimeVal  FlowControlProbeInterval;
                 
                   
                 FlowControlProbeInterval = thePacket.suggestedWakeupTime == -1?(thePacket.packetTransmitTime  - CurrentTime) :
                                                (thePacket.suggestedWakeupTime  - CurrentTime);
                                                
                 if(FlowControlProbeInterval > 0)
                          inParams->outNextPacketTime = FlowControlProbeInterval >10?(FlowControlProbeInterval-10):FlowControlProbeInterval;   
                                     // for buffering, try me again in # MSec
                 else
                          inParams->outNextPacketTime = theSendInterval;//50;    // for buffering, try me again in # MSec                       
                 
                 if(inParams->outNextPacketTime >theSendInterval)
                    inParams->outNextPacketTime =  theSendInterval;
                 
                 LogRequest(DEBUG_ARTS_MODULE, callid, "Flow control Probe interval = %"_64BITARG_"d", inParams->outNextPacketTime);  
                 set_need_idel_time(inParams->outNextPacketTime,sess);
                 return QTSS_NoErr;   
                 
           }else
           {
                if(theErr == QTSS_NotConnected){   
                    LogRequest(INFO_ARTS_MODULE, callid,"QTSS_Teardown,fd:%d",sess->head.sock->fd);              
                    (void)QTSS_Teardown(inParams->inClientSession);
                    return QTSS_NoErr;
                }
                inParams->outNextPacketTime = theSendInterval/5;
                return QTSS_NoErr;
            }   
                                                              
           
           
        }else  if(sess->rtp_packet_buffer)
        {
        // get packet from buffers        
           //LogRequest(DEBUG_ARTS_MODULE, callid,"get packet from buffers");
           custom_struct_t * custom_struct = (custom_struct_t*)sess->darwin_custom_struct;
	       Assert(custom_struct != NULL);   
		  
           if(custom_struct->need_send_packet_num ==0)
           {                 
              custom_struct->need_send_packet_num = 7;              
           }
                     
           inParams->outNextPacketTime  = 0;   
           while( custom_struct->need_send_packet_num >0)
           {               
                char * buf = sess->first_packet.pkt_buf;
                sess->first_packet.pkt_len = 0;
                int pkt_num = 0;
                
                while(true)
                {
                    rtp_packet_buffer_type *cur = sess->rtp_packet_buffer;
                    if(cur == NULL)
                        break;
                     /*
                    if(cur->pts >=0){
                        custom_struct->last_keyframe_pts = cur->pts;
                        custom_struct->offset = 0;
                        LogRequest(DEBUG_ARTS_MODULE, callid,"cur_pts:%d",cur->pts);
                    } 
                        */
                    if(pkt_num==0){
                        sess->last_mpeg2_timestamp = cur->timestamp;
                        custom_struct->pkt_transformat = cur->timestamp;
                    }
                    
                    int tmp1= ARTSMIN(TS_TCP_PACKET_SIZE,custom_struct->need_send_packet_num *TS_PACKET_SIZE);
                    tmp1 -= sess->first_packet.pkt_len;
                    int real_num = ARTSMIN(tmp1,cur->pkt_len);    
                                        
                    memcpy(buf,cur->pkt_buf,real_num);
                    sess->first_packet.pkt_len += real_num;
                    
                    if(custom_struct->last_keyframe_pts >=0 )
                        custom_struct->offset +=  real_num;
                    
                    buf+= real_num;
                    cur->pkt_len -= real_num;
                    
                    if (cur->pkt_len>0)
                    {
                        char tmp_pkt[TS_TCP_PACKET_SIZE];
                        memcpy(tmp_pkt,cur->pkt_buf+real_num,cur->pkt_len);
                        memcpy(cur->pkt_buf,tmp_pkt,cur->pkt_len);
                    }
                    
                    //LogRequest(DEBUG_ARTS_MODULE, callid,"real_num:%d,sess->first_pkt_len:%d,cur->pkt_len:%d",real_num,sess->first_packet.pkt_len,cur->pkt_len);
                    pkt_num = sess->first_packet.pkt_len/TS_PACKET_SIZE;                         
                   
                       
                    ARTS_Get_Packet *sARTSGetPacket = (ARTS_Get_Packet *)custom_struct->receive_pkts_thread;
                    if(cur->pkt_len ==0)  
                    {  
                          int64_t cur_duration = GetFrameDuration(sess);
                          custom_struct->buf_duration -= cur_duration; 
                          
                                              
                          
                          if(sARTSGetPacket != NULL)
                          {                
                                                           
                            OSMutexLocker lockerBuffer(&sARTSGetPacket->bufferMux); 
                           
                                                                               
                            sess->rtp_packet_buffer =(rtp_packet_buffer_type *) cur->next; 
                            LogRequest(INFO_ARTS_MODULE, callid,"this packets PCR:%u,cur_duration:%d,cur_pts:%d,sess->buffer:%x,cur:%x,sess->last_rtp:%x",cur->timestamp,cur_duration,cur->pts,sess->rtp_packet_buffer,cur,sess->last_rtp_packet);
                            cur->next = NULL;
                            free(cur->pkt_buf);
                            free(cur);
                            sess->rtp_packet_buffer_len -= 1;    
                             
                            if(cur == sess->last_rtp_packet)
                            {
                                sess->last_rtp_packet = NULL;                 
                                LogRequest(DEBUG_ARTS_MODULE, callid,"cur_rtp:%x",cur);
                            }     
                        }else
                        {
                            sess->rtp_packet_buffer =(rtp_packet_buffer_type *) cur->next; 
                            LogRequest(DEBUG_ARTS_MODULE, callid,"this packets PCR:%u,cur_duration:%d",cur->timestamp,cur_duration);
                            cur->next = NULL;
                            free(cur->pkt_buf);
                            free(cur);
                            sess->rtp_packet_buffer_len -= 1;  
                             if(cur == sess->last_rtp_packet)
                            {
                                sess->last_rtp_packet = NULL;                 
                                LogRequest(DEBUG_ARTS_MODULE, callid,"cur_rtp:%x",cur);
                            }      
                        }    
                     }  
                     
                     if(pkt_num >= 7 || custom_struct->need_send_packet_num ==pkt_num)
                     {                        
                        break;
                     }                                
                                        
                }
                custom_struct->need_send_packet_num -= pkt_num;  
               // LogRequest(DEBUG_ARTS_MODULE, callid,"left_pkt:%d",custom_struct->need_send_packet_num);
                if(sess->rtp_packet_buffer_len ==0)
                      custom_struct->need_send_packet_num =0;                                   
                goto send;               
           }
           
          
        }else
        {   // no packet in 2sec buffer
        
          if(custom_struct->receive_pkts_thread == NULL)  
          {            
            sendAnnouce(sess);
          }
            inParams->outNextPacketTime = theSendInterval/5;  
           
           return QTSS_NoErr; 
           
        }  
    }
}


/**************************************************************************************
* This function is used to align the endpoint of the clip that was being played. Lets *
* take a look at the problem. Say the two streams are audio and video have duration of*
* 300ms and 66ms respectively.Then the  streams will be something as follows          *
*  audio streams : |----------------300ms-----------|----------------300ms-----------|*
*  video streams : |-66ms-|-66ms-|-66ms-|-66ms-|-66ms-|-66ms-|-66ms-|                 *
* Now it may so happen that the last packet sent in both the stream does not have the *
* There can be various reasons(Can be figured out on your own)                        *
*                                                                                     *
* So assuming that the beginning of first packets are aligned and the duration played *
* should be same so that the clip played after this have their begining aligned.      *
*                                                                                     *
*     if(audio_duration_played > video_duration_played)                               *
*          video_duration_played = audio_duration_played                              *
*     else                                                                            *
*          audio_duration_played = video_duration_played                              *
*                                                                                     *
**************************************************************************************/

void SetStreamsOffset ( arts_session *sess )
{
    UInt32 aud_ts,vid_ts;
    UInt64 aud_duration_played, vid_duration_played;
    UInt32 aud_clock_rate, vid_clock_rate;
    UInt32 diff_correction = 0;
    UInt32 aud_last_pkt_duration , vid_last_pkt_duration;
    UInt32 aud_last_pkt_timestamp , vid_last_pkt_timestamp;

    aud_ts = sess->aud_ts;
    vid_ts = sess->vid_ts;

    aud_clock_rate = sess->rtp_audio_clock_rate;
    vid_clock_rate = sess->rtp_video_clock_rate;

    aud_last_pkt_duration = sess->lastSent_aud_packet_timestamp - sess->lastlastSent_aud_packet_timestamp ;
    vid_last_pkt_duration = sess->lastSent_vid_packet_timestamp - sess->lastlastSent_vid_packet_timestamp ;

    aud_last_pkt_timestamp = sess->lastSent_aud_packet_timestamp ;
    vid_last_pkt_timestamp = sess->lastSent_vid_packet_timestamp ;

    aud_duration_played = (UInt64)( aud_last_pkt_timestamp - aud_ts + aud_last_pkt_duration ) * (UInt64)1000 / (UInt64)aud_clock_rate ;
    vid_duration_played = (UInt64)( vid_last_pkt_timestamp - vid_ts + vid_last_pkt_duration ) * (UInt64)1000 / (UInt64)vid_clock_rate ;

    LogRequest(DEBUG_ARTS_MODULE,sess->callid,"audio duration played : %"_64BITARG_"d video duration played :%"_64BITARG_"d",aud_duration_played,vid_duration_played);


    if( aud_duration_played > vid_duration_played ){
        diff_correction = aud_duration_played - vid_last_pkt_duration*1000 / vid_clock_rate ;

        LogRequest(DEBUG_ARTS_MODULE,sess->callid,"The diff_correction for dif_duration before scaling is:%u",diff_correction);

        // diff_correction = darwin_util_uint64_scale_int ( diff_correction , (SInt32)vid_clock_rate , (SInt32)1000);
        diff_correction = diff_correction * vid_clock_rate / 1000 ;

        LogRequest(DEBUG_ARTS_MODULE,sess->callid,"The diff_correction for diff_duration after scaleing is:%u",diff_correction);

        vid_ts = vid_ts + diff_correction;
        aud_ts = sess->lastSent_aud_packet_timestamp;

    }else if( aud_duration_played < vid_duration_played ){
         diff_correction = vid_duration_played - (aud_last_pkt_duration)*1000 / aud_clock_rate ;

         LogRequest(DEBUG_ARTS_MODULE,sess->callid,"The diff_correction for dif_duration before scaling is:%u",diff_correction);
         
         //diff_correction = darwin_util_uint64_scale_int ( diff_correction , (SInt32)aud_clock_rate , (SInt32)1000);
         diff_correction = diff_correction * aud_clock_rate / 1000 ;
         
         LogRequest(DEBUG_ARTS_MODULE,sess->callid,"The diff_correction for diff_duration after scaleing is:%u",diff_correction);

         aud_ts = aud_ts + diff_correction;
         vid_ts = sess->lastSent_vid_packet_timestamp;
    }

    sess->vid_ts = vid_ts ;
    sess->aud_ts = aud_ts ;
    LogRequest(DEBUG_ARTS_MODULE,sess->callid,"The reset timestamp value for audio stream : %u and for video stream : %u",sess->aud_ts, sess->vid_ts);

}


int64_t GetseekStartDts(arts_session *sess)
{
    if(sess!=NULL&&sess->darwin_custom_struct != NULL)
    {
        custom_struct_t *p = (custom_struct_t*) sess->darwin_custom_struct;
        return  (p->seek_start_dts + ARTSMAX(p->pause_start_time,p->last_recv_PCR));
    }    
    return 0;
}

void RefreshDuration(arts_session **sess,int64_t theDts,int theSendInterval)
{
    if(sess == NULL || (*sess) ==NULL || theDts <0)
        return;
    custom_struct_t * cur_struct = (custom_struct_t *)(*sess)->darwin_custom_struct;
     if(cur_struct != NULL )    
     {  
          if(cur_struct->seek == false)               
          {
                int64_t diffTime=theDts - cur_struct->last_pts;
                //if(theDts < (cur_struct->last_pts -theSendInterval*20)  || (theDts > (cur_struct->last_pts -theSendInterval*20)) )
               if( (diffTime >0 && diffTime> theSendInterval*20) || (diffTime <0 && diffTime < (-1*theSendInterval*20)))
               {
                    cur_struct->seek_start_dts = theDts;
                    (*sess)->first_packet_send_time = QTSS_Milliseconds();
                    LogRequest(DEBUG_ARTS_MODULE, (*sess)->callid,"fresh sess->first_packet_send_time: %"_64BITARG_"d, cur dts:%u,last->dts:%u",(*sess)->first_packet_send_time,theDts,cur_struct->last_pts);
               }else    
                               
                cur_struct->last_pts =theDts;                      
            
           }else
           {
                (*sess)->first_packet_send_time = QTSS_Milliseconds();
                LogRequest(DEBUG_ARTS_MODULE, (*sess)->callid,"after seek new first_send_time:%"_64BITARG_"d",(*sess)->first_packet_send_time);
                cur_struct->seek = false;                         
           }                  
      }
}




QTSS_Error SendPackets(QTSS_RTPSendPackets_Params* inParams)
{	
    QTSS_Error theErr = QTSS_NoErr;
    UInt32 callid, theLen = sizeof(callid); 
	UInt32 theSendInterval = QTSServerInterface::GetServer()->GetPrefs()->GetSendIntervalInMsec();
	bool isBeginningOfWriteBurst = true;
	QTSS_WriteFlags theFlags = qtssWriteFlagsIsRTP;
	
	
    
#if ! DO_BLOCK_READ
      
#endif
    theErr = QTSS_GetValue(inParams->inClientSession, sARTSSessionAttr, 0, &callid, &theLen);
    Assert(theErr == QTSS_NoErr);
    LogRequest(DEBUG_ARTS_MODULE, callid, "SendPackets: Entering ,current_time:%"_64BITARG_"d" ,QTSS_Milliseconds());
    arts_session *sess = NULL;
    {
        //LogRequest(DEBUG_ARTS_MODULE,callid,"start get session");
        //OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
        sess = arts_session_find(callid);
        //LogRequest(DEBUG_ARTS_MODULE, callid,"this->sess:%x",sess);
    }
    if(!sess)
    { 
        LogRequest(DEBUG_ARTS_MODULE, callid,"sess is null");
        return QTSS_NoErr;
    }
    
    
    if(sess->transport_type == qtssRTPTransportTypeMPEG2)
    {
        return SendMpeg2Packets(inParams);
    }
	
	
    while(true)
    {
    
         LogRequest(DEBUG_ARTS_MODULE, callid, "sess->first_packet.pkt_len:%d ,sess->buffer_len:%d,sess->rtp_packet_buffer:%x",sess->first_packet.pkt_len,sess->rtp_packet_buffer_len,sess->rtp_packet_buffer);
        if(sess->first_packet.pkt_len > 0)
        {
            // There was a packet, so send it to the client          
            set_need_idel_time(0,sess);
            
            QTSS_PacketStruct thePacket;   
            
            memset(sess->first_packet.pkt_buf,sess->first_packet.pkt_buf[0]&0xdf,1);           
            thePacket.packetData = sess->first_packet.pkt_buf; 
                       
            UInt32* theTimeStampP = (UInt32*)thePacket.packetData;
            UInt32 theTimeStamp = ntohl(theTimeStampP[1]);
                       
            UInt8* padding_lenP = (UInt8*)(thePacket.packetData + sess->first_packet.pkt_len-1);
            UInt8  padding_len=padding_lenP[0];
           
            UInt32* dtsP =(UInt32*) ((UInt8*) ( thePacket.packetData +sess->first_packet.pkt_len - padding_len )); 
            UInt32 theDts = ntohl(dtsP[0]);

            UInt16* theSeqNumP = (UInt16*)thePacket.packetData;
            UInt16 theSeqNum = ntohs(theSeqNumP[1]);
			UInt64 realSeqNum;
                                
            
            if(sess->first_packet.pkt_str == 2)
            {				
                if(theSeqNum != sess->lastSent_aud_packet_seqnum)
                {                   
					if( (sess->aud_discont == 1))
					{  
                        sess->aud_seqnumOffset = sess->lastSent_aud_packet_seqnum; //(no delta required since first seqnum is 1)
                      
                        sess->aud_discont = 0;                      
						qtss_printf("Resetting Audio Timestamp and SeqNum to %u, %u \n", sess->aud_ts, sess->aud_seqnumOffset);
                    }


                    *(theSeqNumP+1) =    htons( theSeqNum) ;//htons(sess->aud_seqnumOffset + theSeqNum);
                    *(theTimeStampP+1) =  htonl( theTimeStamp);//htonl(sess->aud_ts + theTimeStamp) ;

                    theTimeStamp = ntohl(theTimeStampP[1]);
                    theSeqNum = ntohs(theSeqNumP[1]);
					
					if ( sess->lastSent_aud_packet_seqnum > (theSeqNum + 0x7fff)) 
						sess->audio_rtp_seqnum_warp_offset += 0xffff; 
                    
                    sess->lastSent_aud_packet_seqnum = theSeqNum;
                }
				
				realSeqNum = theSeqNum + sess->audio_rtp_seqnum_warp_offset;			
				QTSS_TimeVal  CurrentTime = QTSS_Milliseconds();							
				
				RefreshDuration(&sess,theDts,theSendInterval);				
				thePacket.packetTransmitTime = sess->first_packet_send_time + (theDts -  GetseekStartDts(sess)) ;
				
				/*pts
				if ( theTimeStamp > sess->rtp_audio_timestamp )
                  thePacket.packetTransmitTime = sess->first_packet_send_time + ( ((SInt64)(theTimeStamp - sess->rtp_audio_timestamp) * (SInt64) 1000) /(SInt64)(sess->rtp_audio_clock_rate));
			    else
				  thePacket.packetTransmitTime = sess->first_packet_send_time;
				  //	pts	
				  */
				
	            if(thePacket.packetTransmitTime -CurrentTime >  theSendInterval *10)
	            {
	                inParams->outNextPacketTime = theSendInterval *9;
	                LogRequest(DEBUG_ARTS_MODULE, callid,"cur pkts transmittime:%"_64BITARG_"d,outNextPacketTime:%"_64BITARG_"d",thePacket.packetTransmitTime,inParams->outNextPacketTime);
                    return QTSS_NoErr; 
	            }
	            		
				if (isBeginningOfWriteBurst)
					theFlags |= qtssWriteFlagsWriteBurstBegin;
				
				if ( realSeqNum >=  (sess->real_rtp_audio_seqnum) )
				{	    
				
                   theErr = QTSS_Write(sess->audio_str, &thePacket, sess->first_packet.pkt_len-padding_len, NULL, qtssWriteFlagsIsRTP);                  
                   
                   LogRequest(DEBUG_ARTS_MODULE, callid,"--send type = a, theTimeStamp = %u, theErr:%d,CurrentTime %"_64BITARG_"d,Pkt_transtime = %"_64BITARG_"d,delay:%"_64BITARG_"d,dts:%u,pkt_len:%d",theTimeStamp,theErr,CurrentTime,thePacket.packetTransmitTime, (CurrentTime-thePacket.packetTransmitTime),theDts,sess->first_packet.pkt_len-padding_len);
                }
			    else 
					qtss_printf("packet dropped seq: %d, first-seq:%d ,real-seq:%"_64BITARG_"d, real_first_seq:%"_64BITARG_"d, CurrentTime %"_64BITARG_"d \n", 
								theSeqNum, sess->rtp_audio_seqnum ,realSeqNum, sess->real_rtp_audio_seqnum, QTSS_Milliseconds());
          
                if(!theErr)
                {
                    sess->lastlastSent_aud_packet_timestamp = sess->lastSent_aud_packet_timestamp;
                    sess->lastSent_aud_packet_timestamp = theTimeStamp;               
                }              

            }
            else if(sess->first_packet.pkt_str == 3 || sess->first_packet.pkt_str == 1)
            {
                if(theSeqNum != sess->lastSent_vid_packet_seqnum)
                {
                   if( (sess->vid_discont == 1))
                   {
                        sess->vid_seqnumOffset = sess->lastSent_vid_packet_seqnum; //(no delta required since first seqnum is 1)                         
                        sess->vid_discont = 0;                       
						qtss_printf( "Resetting Video Timestamp and SeqNum to %u, %u \n", sess->vid_ts, sess->vid_seqnumOffset);
                    }

                    *(theSeqNumP+1) = htons( theSeqNum);//htons(sess->vid_seqnumOffset + theSeqNum);
                    *(theTimeStampP+1) = htonl(theTimeStamp);//htonl(sess->vid_ts + theTimeStamp) ;                    
                    theTimeStamp = ntohl(theTimeStampP[1]);
                    theSeqNum = ntohs(theSeqNumP[1]);                  
					if ( sess->lastSent_vid_packet_seqnum > (theSeqNum + 0x7fff)) 
						sess->video_rtp_seqnum_warp_offset += 0xffff; 					
                    sess->lastSent_vid_packet_seqnum = theSeqNum;                  
                }
				
				realSeqNum = theSeqNum + sess->video_rtp_seqnum_warp_offset;
				
				RefreshDuration(&sess,theDts,theSendInterval);									
				thePacket.packetTransmitTime = sess->first_packet_send_time +  (theDts -  GetseekStartDts(sess)) ;
				
			
				
				QTSS_TimeVal  CurrentTime = QTSS_Milliseconds();					
				if(thePacket.packetTransmitTime -CurrentTime >  theSendInterval *10)
	            {
	                inParams->outNextPacketTime = theSendInterval ;
	                 LogRequest(DEBUG_ARTS_MODULE, callid,"cur pkts transmittime:%"_64BITARG_"d,startdts:%u,first_packet_send_time:%"_64BITARG_"d,dts:%u",inParams->outNextPacketTime, GetseekStartDts(sess),sess->first_packet_send_time,theDts);
	                
                    return QTSS_NoErr; 
	            }			
				
				if (isBeginningOfWriteBurst)
					theFlags |= qtssWriteFlagsWriteBurstBegin;
               
				if ( realSeqNum >=  (sess->real_rtp_video_seqnum ))
				{				    
				   theErr = QTSS_Write(sess->video_str, &thePacket, sess->first_packet.pkt_len-padding_len, NULL, theFlags);				   
				   LogRequest(DEBUG_ARTS_MODULE, callid,"--send type = v, theTimeStamp = %u,theErr:%d.CurrentTime %"_64BITARG_"d,Pkt_transtime = %"_64BITARG_"d,delay:%"_64BITARG_"d,dts:%u,pkt_len:%d",theTimeStamp,theErr,CurrentTime,thePacket.packetTransmitTime,(CurrentTime-thePacket.packetTransmitTime),theDts,sess->first_packet.pkt_len-padding_len);
				}
			    else 
				{
				   qtss_printf("packet dropped seq: %d, first-seq:%d ,real-seq:%"_64BITARG_"d,real-first-seq:%"_64BITARG_"d, CurrentTime %"_64BITARG_"d \n", 
							   theSeqNum, sess->rtp_video_seqnum , realSeqNum, sess->real_rtp_video_seqnum, QTSS_Milliseconds());				   
				}             
				
                if(!theErr)
                {
                    sess->lastlastSent_vid_packet_timestamp = sess->lastSent_vid_packet_timestamp;
                    sess->lastSent_vid_packet_timestamp = theTimeStamp;                  
                }                
            }     
            
			isBeginningOfWriteBurst = false;

#if DO_BLOCK_READ
            {
                QTSS_TimeVal  CurrentTime = QTSS_Milliseconds();              
                if (thePacket.packetTransmitTime < CurrentTime)
                    LogRequest(DEBUG_ARTS_MODULE, callid, "Packet should have been sent earlier by %d msecs", CurrentTime - thePacket.packetTransmitTime);
            }
#endif
            if(theErr != QTSS_NoErr) 
            {
                if(theErr == QTSS_WouldBlock)
                {
                   QTSS_TimeVal  CurrentTime = QTSS_Milliseconds();
                   QTSS_TimeVal  FlowControlProbeInterval;
                  
                   
                   FlowControlProbeInterval = thePacket.suggestedWakeupTime == -1?(thePacket.packetTransmitTime  - CurrentTime) :
                                                (thePacket.suggestedWakeupTime  - CurrentTime);
                                                
                    if(FlowControlProbeInterval > 0)
                            inParams->outNextPacketTime = FlowControlProbeInterval >10?(FlowControlProbeInterval-10):FlowControlProbeInterval;   
                                     // for buffering, try me again in # MSec
                    else
                            inParams->outNextPacketTime = theSendInterval;//50;    // for buffering, try me again in # MSec                       

                    LogRequest(DEBUG_ARTS_MODULE, callid, "Flow control Probe interval = %"_64BITARG_"d", inParams->outNextPacketTime);  
                    set_need_idel_time(inParams->outNextPacketTime,sess);
                    return QTSS_NoErr;       
                }
                else
                {
                
                    if(theErr == QTSS_NotConnected){ 
                        LogRequest(DEBUG_ARTS_MODULE, callid,"QTSS_Teardown");                   
                        (void)QTSS_Teardown(inParams->inClientSession);
                        return QTSS_NoErr; 
                    }
                    
                    inParams->outNextPacketTime = theSendInterval/5;
                    return QTSS_NoErr; 
                }

            }
            else
            {
                if(sess->first_packet.pkt_str == 2)
                {
                    sess->rtp_audio_bytes_sent += sess->first_packet.pkt_len;
                    sess->rtp_last_audio_timestamp = theTimeStamp;
                }
                if(sess->first_packet.pkt_str == 3)
                {
                    sess->rtp_video_bytes_sent += sess->first_packet.pkt_len;
                    sess->rtp_last_video_timestamp = theTimeStamp;
                }
                sess->first_packet.pkt_len = 0; 
               
            }      
        }
        
 

#if DO_BLOCK_READ
        if(sess->rtp_packet_buffer && sess->rtp_packet_buffer_len > MIN_RTP_PACKET_BUFFER_LEN )
#else
        
        if(sess->rtp_packet_buffer )        
#endif
        {
            ARTS_Get_Packet *sARTSGetPacket = NULL;
            
            if(sess->darwin_custom_struct != NULL)
            {
               custom_struct_t *custom_struct = ( custom_struct_t *)sess->darwin_custom_struct;            
                sARTSGetPacket = (ARTS_Get_Packet *)custom_struct->receive_pkts_thread;
                if(sARTSGetPacket != NULL)
                {                    
                    OSMutexLocker lockerBuffer(&sARTSGetPacket->bufferMux);
                    sess->rtp_packet_buffer_len--;
                    
                 }else
                    sess->rtp_packet_buffer_len--;         
              
                 
                 int64_t cur_duration = GetFrameDuration(sess);
                 custom_struct->buf_duration -= cur_duration; 
                           
                                       
                 LogRequest(DEBUG_ARTS_MODULE, sess->callid, "get packet from buffer,current_duration = %"_64BITARG_"d,curtime:%"_64BITARG_"d,Duration:%u,buf_len:%d", custom_struct->buf_duration,QTSS_Milliseconds(),cur_duration,sess->rtp_packet_buffer_len);
                              
            }else
            {
                sess->rtp_packet_buffer_len --;
                LogRequest(INFO_ARTS_MODULE, sess->callid,"sess->darwin_custom_struct is null");
            }           

                             

            rtp_packet_buffer_type  *rtp_packet_buffer = sess->rtp_packet_buffer;
            memcpy(sess->first_packet.pkt_buf, sess->rtp_packet_buffer->pkt_buf, sess->rtp_packet_buffer->pkt_len);
            sess->first_packet.pkt_len = sess->rtp_packet_buffer->pkt_len;
            sess->first_packet.pkt_str = sess->rtp_packet_buffer->pkt_str;
           
            
             if(sARTSGetPacket != NULL)
            {           
                OSMutexLocker lockerBuffer(&sARTSGetPacket->bufferMux);
                sess->rtp_packet_buffer = (rtp_packet_buffer_type  *)sess->rtp_packet_buffer->next;
            }else
            {
                sess->rtp_packet_buffer = (rtp_packet_buffer_type  *)sess->rtp_packet_buffer->next;
            }

            rtp_packet_buffer->next = NULL;
            free(rtp_packet_buffer->pkt_buf);
            free(rtp_packet_buffer);
        }
        
        else
        {
            inParams->outNextPacketTime = theSendInterval/5;
            return QTSS_NoErr;  
        }
    }
    LogRequest(DEBUG_ARTS_MODULE, callid, "Exiting");

    return QTSS_NoErr; 
}


static void get_pts(arts_session * sess)
{
    if(sess->rtp_packet_buffer == NULL || sess->rtp_packet_buffer_len ==0)
    {
        return ;
    }
    custom_struct_t * custom_struct = (custom_struct_t *)sess->darwin_custom_struct;
    rtp_packet_buffer_type * p  = sess->rtp_packet_buffer;
    while(p && p->pkt_len >0)
    {
        char * ptr = p->pkt_buf;
        int pkt_len = p->pkt_len;
        int64_t PTS,tmpPCR,dts;
        
        while(pkt_len )
        {
            
            PTS = -1;
            tmpPCR =-1;
            dts =-1;
                    //tmpPCR = GetMPEG2PCR(ptr, &pktLen,&PTS,&(custom_struct->ts));
            MpegTSContext*ts = (MpegTSContext*)custom_struct->tsctx;
            dts=handle_pkt_simple(ts,(unsigned char*)ptr,TS_PACKET_SIZE,&tmpPCR,&PTS,true);
            if(PTS>0)
            {
                if(custom_struct->last_keyframe_pts == -1)
                {
                    custom_struct->last_keyframe_pts = PTS;
                     LogRequest(INFO_ARTS_MODULE, sess->callid,"get PTS-MS:%d", PTS/90);
                    return ;
                }
            }
            ptr += TS_PACKET_SIZE;
            pkt_len -= TS_PACKET_SIZE;
        }
        
         p= (rtp_packet_buffer_type * )p->next;
    }
}


QTSS_Error DoPause(QTSS_StandardRTSP_Params* inParams)
{
    QTSS_Error err = QTSS_NoErr;
   
    UInt32 callid, attributeLen = 0,theLen = sizeof(callid);

    err = QTSS_GetValue(inParams->inClientSession, sARTSSessionAttr, 0, &callid, &theLen);
    Assert(err == QTSS_NoErr);
	arts_session *sess = NULL;
    {
		OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
	    sess = arts_session_find(callid);
    }
    if(!sess) return QTSS_NoErr;

    //LogRequest(INFO_ARTS_MODULE, callid, "Entering DoPause");
	/*
	
	//LiJie modified on 2012.09.19
	//add play range support, or rtsp seek support for ARTS	
	
	char *theRequestAttributes=NULL;
	arts_rtsp_additional_headers rtspHeader;
    memset(&rtspHeader, 0, sizeof(rtspHeader));
	
    rtspHeader.callid = callid;
    strcpy(rtspHeader.method,"Pause");

	int numKeyValues = 0;
	int numMoreHeaders = 1; //only Range header	now
	
	rtspHeader.keyValuePairs = arts_ph_create_keyvalues(numMoreHeaders);
	
	err = QTSS_GetValuePtr(inParams->inRTSPHeaders, qtssRangeHeader, 0,(void **)&theRequestAttributes,&attributeLen);
	
	if(err == QTSS_NoErr)
    {
		char sRangeHeader[256];
        strncpy(sRangeHeader,theRequestAttributes,attributeLen);
        sRangeHeader[attributeLen] = '\0';		
	
		arts_ph_calloc_keyvalue(rtspHeader.keyValuePairs, numKeyValues, "Range", sRangeHeader);
		numKeyValues++;
    }	
	
	rtspHeader.numKeyValuePairs = numKeyValues;
	//JieLi	
	
	arts_send_additional_rtsp_Headers(sARTSPHInterface->controlsock->fd, &rtspHeader); //send rtsp headers to controller

	//LiJie modified on 2012.09.19
	arts_ph_delete_keyvalues(rtspHeader.keyValuePairs, numMoreHeaders);
	//JieLi	
	
    // Signal the other task to pause the connection
    
    
    //sess->head.state |= ARTS_CALL_STATE_PAUSE;
    */
    custom_struct_t *custom_struct = (custom_struct_t*)sess->darwin_custom_struct;
    Assert(custom_struct!= NULL);
    custom_struct ->pause = true;
    custom_struct->pause_start_time =0;
    custom_struct->last_keyframe_pts = -1;
    custom_struct->pkt_transformat = 0;
    if(custom_struct->isIpqam == true)
    {
         timeout_ev_t *curSendEv = (timeout_ev_t *)custom_struct->sendEv;
         curSendEv->pause = true;
    
    }else
    {

        err = QTSS_Pause(inParams->inClientSession);
        Assert(err == QTSS_NoErr); 
    } 
    
    err =  QTSS_SendStandardRTSPResponse(inParams->inRTSPRequest, inParams->inClientSession, 0);
    Assert(err == QTSS_NoErr);
    
    //GetStreamPackets(sess, false);
    //OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
    //init_thread(sess);
    get_pts( sess);
    LogRequest(INFO_ARTS_MODULE, callid, "Exiting");     

    return err;
}

//added by lijie, 2010.09.30
//close rtsp sessions established by Describe request (adapter pipeline created), 
//but disconnected by client before send SETUP request (no rtp session established).

QTSS_Error CloseRTSPSession(QTSS_RTSPSession_Params* inParams)
{
    QTSS_Error err = QTSS_NoErr;
    UInt32 callid, theLen = sizeof(callid);
	
    err = QTSS_GetValue(inParams->inRTSPSession, sARTSRTSPSessionAttr, 0, &callid, &theLen);
    Assert(err == QTSS_NoErr);
    Assert(sARTSRTSPSessionAttr != qtssIllegalAttrID);    
	
    OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
    arts_session *sess = arts_session_find(callid);
    if(!sess) return QTSS_NoErr;
	
	//no action if any rtp session is available for this rtsp session
	if (sess->video_str || sess->audio_str) return QTSS_NoErr;
	
    //UpdateRTSPStats(inParams->inClientSession,sess);
    
    LogRequest(INFO_ARTS_MODULE, callid, "Entering CloseRTSPSession");
	
    LogRequest(INFO_ARTS_MODULE, callid, "Audio RTP Bytes Sent = %u", sess->rtp_audio_bytes_sent);
	
    LogRequest(INFO_ARTS_MODULE, callid, "Video RTP Bytes Sent = %u", sess->rtp_video_bytes_sent);
	
    LogRequest(INFO_ARTS_MODULE, callid, "Mpeg2 TS Bytes Sent = %u", sess->rtp_mpeg2_bytes_sent);
	
    if(!(sess->head.state & ARTS_CALL_STATE_DESTROY_NOW))
    {		
        sess->ReleaseCause = proto64::UserDisconnected;
    }
	
    LogRequest(INFO_ARTS_MODULE, callid, "Release Cause = %d", sess->ReleaseCause);
	
    // Check the controller state before sending to avoid contention for fd write
    if ((sARTSPHInterface->control_state == ARTS_CONTROLLER_STATE_ACTIVE) &&
        (!(sess->head.state & ARTS_CALL_STATE_RELEASE_SENT)))
    {
        arts_send_conrel(sARTSPHInterface->controlsock->fd, sess, ARTS_PH_TYPE_RTSP);
		//sess->head.state |= ARTS_CALL_STATE_RELEASE_SENT;
        LogRequest(INFO_ARTS_MODULE, callid, "Release Sent to Controller. Cause = %d", sess->ReleaseCause);
    }
    // Signal the other task to cleanup the connection
    
    custom_struct_t * cur_struct = (custom_struct_t *)sess->darwin_custom_struct;
    if( (cur_struct!=NULL && cur_struct->receive_pkts_thread == NULL) || sess->head.sock == NULL)
    {
        // adapter close first
        free_custom_struct(sess,NULL);  
        arts_session_free(sess,1);
        LogRequest(INFO_ARTS_MODULE, callid,"free session");
    }else
    {
        //client close first
        cur_struct->buf_duration =0;
        sess->head.state = ARTS_CALL_STATE_DESTROY_NOW;
    }
       
	
    LogRequest(INFO_ARTS_MODULE, callid, "Exiting");
	
    return QTSS_NoErr;
}
//jieli




QTSS_Error DestroySession(QTSS_ClientSessionClosing_Params* inParams)
{
    QTSS_Error err = QTSS_NoErr;
    UInt32 callid, theLen = sizeof(callid);
    LogRequest(INFO_ARTS_MODULE, 0, "Entering DestroySession");

    err = QTSS_GetValue(inParams->inClientSession, sARTSSessionAttr, 0, &callid, &theLen);
    Assert(err == QTSS_NoErr);
    Assert(sARTSSessionAttr != qtssIllegalAttrID);

    OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
    arts_session *sess = arts_session_find(callid);
    if(!sess)
    { 
        LogRequest(INFO_ARTS_MODULE, 0,"sess is null");
        return QTSS_NoErr;
    }
	
	LogRequest(INFO_ARTS_MODULE, callid, "Audio RTP Bytes Sent = %u", sess->rtp_audio_bytes_sent);
	
    UpdateRTSPStats(inParams->inClientSession,sess);  

    

    LogRequest(INFO_ARTS_MODULE, callid, "Video RTP Bytes Sent = %u", sess->rtp_video_bytes_sent);

    LogRequest(INFO_ARTS_MODULE, callid, "Mpeg2 TS Bytes Sent = %u", sess->rtp_mpeg2_bytes_sent);

    if(!(sess->head.state & ARTS_CALL_STATE_DESTROY_NOW))
    {

        if(inParams->inReason == qtssCliSesCloseClientTeardown)
            sess->ReleaseCause = proto64::Normal;
                  
        if(inParams->inReason == qtssCliSesCloseTimeout)
            sess->ReleaseCause = proto64::PHDisconnected;
                  
        if(inParams->inReason == qtssCliSesCloseClientDisconnect)
            sess->ReleaseCause = proto64::UserDisconnected;
    }

    LogRequest(INFO_ARTS_MODULE, callid, "Release Cause = %d", sess->ReleaseCause);

    // Check the controller state before sending to avoid contention for fd write
    if ((sARTSPHInterface->control_state == ARTS_CONTROLLER_STATE_ACTIVE) &&
        (!(sess->head.state & ARTS_CALL_STATE_RELEASE_SENT)))
    {
        arts_send_conrel(sARTSPHInterface->controlsock->fd, sess, ARTS_PH_TYPE_RTSP);
		//sess->head.state |= ARTS_CALL_STATE_RELEASE_SENT;
        LogRequest(INFO_ARTS_MODULE, callid, "Release Sent to Controller. Cause = %d", sess->ReleaseCause);
    }   
    custom_struct_t * cur_struct = (custom_struct_t *)sess->darwin_custom_struct;
    if(cur_struct != NULL && sARTSSendPktThread!= NULL && cur_struct->isIpqam == true)
    {    
        OSMutexLocker registListMutex(&sARTSSendPktThread->regist_list_Mutex);
        sARTSSendPktThread->del_sendEv(sess->callid);
    }
    
    if( (cur_struct!=NULL && cur_struct->receive_pkts_thread == NULL) ||  sess->head.sock == NULL)
    { 
        // adapter close first
        free_custom_struct(sess,NULL);  
        arts_session_free(sess,1);
        LogRequest(INFO_ARTS_MODULE, callid,"free session");
    }else
    {
        //client close first
        cur_struct->buf_duration =0;
        sess->head.state = ARTS_CALL_STATE_DESTROY_NOW;
    }
  
    /*
    bool need_free_sess=0;  
    free_custom_struct(sess,&need_free_sess);   
    
    sess->darwin_custom_struct = NULL;
    sess->head.state = ARTS_CALL_STATE_DESTROY_NOW;
    if(need_free_sess == true)
    {       
        
        del_events_node(sess->head.sock->fd);
        //LogRequest(INFO_ARTS_MODULE, callid,"free event node");
        sess->event_release = 1;
        fdevent_event_del(sARTSPHInterface->ev, sess->head.sock);
        fdevent_unregister(sARTSPHInterface->ev,sess->head.sock);
        arts_session_free(sess,1);
        LogRequest(INFO_ARTS_MODULE, callid,"free session");
        sARTSPHInterface->polltimeout= 1000;
    }
    //arts_session *sess12 = arts_session_find(callid);
    */
    LogRequest(INFO_ARTS_MODULE, callid,"after arts_session_free, custom_struct:%x",sess->darwin_custom_struct);
     
    return QTSS_NoErr;
}

QTSS_Error ProcessRTCPPacket(QTSS_RTCPProcess_Params * inParams)
{
	QTSS_ClientSessionObject theClientSession = NULL;
    QTSS_Error err = QTSS_NoErr;
    UInt32 callid, theLen = sizeof(callid);

    err = QTSS_GetValue(inParams->inClientSession, sARTSSessionAttr, 0, &callid, &theLen);
    Assert(err == QTSS_NoErr);
    Assert(sARTSSessionAttr != qtssIllegalAttrID);
	
	OSMutexLocker l_autoMutex(&sARTSPHInterface->sessionMutex);
	arts_session *sess = arts_session_find(callid);
	
	if (sess)
		theClientSession = sess->remote_con;
	else
		return QTSS_Unimplemented;
	
	UInt32 packetlossrate;
	RTCPPacket rtcppacket;
	LogRequest(INFO_ARTS_MODULE, callid, "Starting Process RTCP Packet %s", "");
	UInt8 *ptr = (UInt8 *)(inParams->inRTCPPacketData);
	if (rtcppacket.ParsePacket(ptr,inParams->inRTCPPacketDataLen))
	{
		LogRequest(INFO_ARTS_MODULE, callid,"Packet type is %d",rtcppacket.GetPacketType());
		RTCPReceiverPacket rtcprpacket;
		if(rtcprpacket.ParseReport((UInt8*)(inParams->inRTCPPacketData),inParams->inRTCPPacketDataLen))
		{	
			if(sARTSPHInterface->control_state == ARTS_CONTROLLER_STATE_ACTIVE && (sess->head.state & ARTS_CALL_STATE_CONNECTED) 
			   && (! (sess->head.state & ARTS_CALL_STATE_DESTROY))&&(! (sess->head.state & ARTS_CALL_STATE_DESTROY_NOW))) 
	        {
		       packetlossrate = rtcprpacket.GetFractionLostPackets(0);
			   //unsigned int current_bandwidth = theClientSession->CurrentBitRate();
			   	UInt32 theBitRate = 0;
				UInt32 *theByteSent = 0;
				UInt32 theLen = 0;	
				(void)QTSS_GetValuePtr(theClientSession, qtssCliSesCurrentBitRate, 0, (void **)&theBitRate, &theLen);		       
			   /*LogRequest(INFO_ARTS_MODULE, callid, "extended highest sequence number received on last %d", rtcprpacket.GetHighestSeqNumReceived(rtcprpacket.GetReportCount()));
			   LogRequest(INFO_ARTS_MODULE, callid, "total fraction lost packet:%d", rtcprpacket.GetCumulativeFractionLostPackets());
			   LogRequest(INFO_ARTS_MODULE, callid, "total lost packet:%d", rtcprpacket.GetCumulativeTotalLostPackets());
			   for (unsigned int i=0;i<rtcprpacket.GetReportCount();i++)
			   {
			   LogRequest(INFO_ARTS_MODULE, callid, "extended highest sequence number received on %d report: %d", i,rtcprpacket.GetHighestSeqNumReceived(0));
			   LogRequest(INFO_ARTS_MODULE, callid, "lost packet in %d report:%d",i, rtcprpacket.GetTotalLostPackets(0));
			   LogRequest(INFO_ARTS_MODULE, callid, "Delay from last sent report in %d report:%d",i, rtcprpacket.GetLastSenderReportDelay(0));
		       }*/
			   
			   	       
			   //LogRequest(INFO_ARTS_MODULE, callid, "Send packetlossrate to Controller.current_bandwidth=%d , packetlossrate = %d",*theBitRate, packetlossrate);
			   QTSS_GetValuePtr(theClientSession, qtssCliSesRTPBytesSent, 0, (void **)&theByteSent, &theLen);
			   LogRequest(INFO_ARTS_MODULE, callid, "RTP Byte Sent : %d , Last Byte Sent : %d",*theByteSent,sess->last_rtsp_bytes_sent);
			   //QTSS_GetValuePtr(theClientSession, qtssCliSesRTPPacketsSent, 0, (void **)&theBitRate, &theLen);
			   //LogRequest(INFO_ARTS_MODULE, callid, "RTP Packets Sent : %d",*theBitRate);
			   UInt64 CurrentTime = QTSS_Milliseconds();
			   float TimeInterval = (CurrentTime - sess->last_rtsp_bitrate_update_time)/1000.0;
			   if(TimeInterval < 1.0)
			   return QTSS_NoErr;
			   
			   LogRequest(INFO_ARTS_MODULE, callid, "Time from last RR report : %f",TimeInterval);
               theBitRate = (UInt32)((*theByteSent - sess->last_rtsp_bytes_sent)/ TimeInterval);			                
			   arts_send_bandwith(sARTSPHInterface->controlsock->fd,sess,theBitRate,packetlossrate);
			   sess->last_rtsp_bytes_sent = *theByteSent;
			   sess->last_rtsp_bitrate_update_time = CurrentTime;
               LogRequest(INFO_ARTS_MODULE, callid, "Send packetlossrate to Controller.current_bandwidth=%d , packetlossrate = %d",theBitRate, packetlossrate);
			   return QTSS_NoErr;
	        }
	        else
			{
			   LogRequest(INFO_ARTS_MODULE, callid, "Nothing to do with RTCP packet! %s", "");
			   return QTSS_OutOfState;
		    }
		}
		else		      
		LogRequest(INFO_ARTS_MODULE, callid, "The RTCP Packet is not APP RTCP Packet !%s", "");
		return QTSS_Unimplemented;
		
	}
	return QTSS_Unimplemented;
	
	
}

static void UpdateRTSPStats(QTSS_ClientSessionObject &inClientSession,arts_session *sess)
{ 
     
     QTSS_RTPStreamObject* streamObject=NULL; 
     long* ptrRtpPacketLost = NULL;
     long* ptrRtpPacketJitter = NULL;
     UInt32 theLen =0;


    /*    All of the attributes of QTSS_ClientSessionObject are preemptive safe, 
       so they can be read by calling QTSS_GetValue, QTSS_GetValueAsString, or QTSS_GetValuePtr.
    */
    /* 
       All of the attributes of QTSS_RTPStreamObject are preemptive safe, 
       so they can be read by calling QTSS_GetValue, QTSS_GetValueAsString, or QTSS_GetValuePtr.
    */


     if ( (sess->head.state == ARTS_CALL_STATE_UNSET )||
          !(sess->head.state & ARTS_CALL_STATE_CONNECTED ) ||
           (sess->rtp_audio_bytes_sent + sess->rtp_video_bytes_sent) == 0)
        
     {
         return;
     }

    QTSS_Error err = QTSS_GetValuePtr(inClientSession, qtssCliSesStreamObjects, 0, (void**)&streamObject, &theLen);
    Assert ((err != QTSS_NoErr) || (theLen != sizeof(QTSS_RTPStreamObject*)) || (streamObject == NULL));
       


    theLen = sizeof(sess->rtp_packets_lost);
    ptrRtpPacketLost = &sess->rtp_packets_lost;

    
    err = QTSS_GetValuePtr(*streamObject, qtssRTPStrTotalLostPackets, 0, (void**)&ptrRtpPacketLost, &theLen);
    Assert ((err != QTSS_NoErr) || (theLen != sizeof(long*)) || (ptrRtpPacketLost == NULL));
       
 

    ptrRtpPacketJitter = &sess->rtp_jitter;
    err = QTSS_GetValuePtr(*streamObject, qtssRTPStrJitter, 0,(void**) &ptrRtpPacketJitter, &theLen);
    Assert((err != QTSS_NoErr) || (theLen != sizeof(long*)) || (ptrRtpPacketJitter == NULL));
      
 
    

    return;
}
static QTSS_Error Shutdown()
{
    delete [] sARTSSystemName;
    delete [] sARTSBackends;
    delete [] sARTSBindHost;
//    delete [] sARTSHandleDir;
    refresh_socket_list(true);
    WriteShutdownMessage();
    qtss_printf("start stop phthread\n");
    sARTSPHInterface->StopAndWaitForThread();
    qtss_printf("start arts_sessions_free()\n");
    arts_sessions_free();
    qtss_printf("start delete obj()\n");
    delete sARTSPHInterface;
    qtss_printf("finish\n");
    return QTSS_NoErr;
}
